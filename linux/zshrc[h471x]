# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.
if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
  source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi

set autocd #change directory just by typing his name
setopt promptsubst #enable command substitution in prompt

# Binary
CUPP_PATH=/usr/share/cupp
HOME_PATH=$HOME/bin

PATH=$CUPP_PATH:$HOME_PATH:$PATH

fastfile_var_prefix='$'

# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"
ZSH_THEME="powerlevel10k/powerlevel10k"

# Declare the variable for zsh-syntax-highlighting 
# styles configurations 
typeset -A ZSH_HIGHLIGHT_STYLES

# ZSH_HIGHLIGHT_STYLES[path]='fg=#5454ff,bold'
ZSH_HIGHLIGHT_STYLES[path]='none'
ZSH_HIGHLIGHT_STYLES[autodirectory]=fg='#ffffff'
ZSH_HIGHLIGHT_STYLES[suffix-alias]=fg='none'
ZSH_HIGHLIGHT_STYLES[precommand]=fg='none'
ZSH_HIGHLIGHT_STYLES[arg0]=fg='none'
ZSH_HIGHLIGHT_STYLES[single-quoted-argument]=fg='#23ff45'
ZSH_HIGHLIGHT_STYLES[double-quoted-argument]=fg='#23ff45'
ZSH_HIGHLIGHT_STYLES[single-hyphen-option]='fg=#37b0ff,bold'
ZSH_HIGHLIGHT_STYLES[double-hyphen-option]='fg=#37b0ff,bold'
ZSH_HIGHLIGHT_STYLES[redirection]='fg=#ffe541,bold'
ZSH_HIGHLIGHT_STYLES[globbing]='fg=#ff9000,bold'
ZSH_HIGHLIGHT_STYLES[command-substitution-unquoted]='fg=#d30ccf,bold'
ZSH_HIGHLIGHT_STYLES[command-substitution-delimiter]='fg=#d30ccf,bold'
# ZSH_HIGHLIGHT_MAXLENGTH=0
#Here to launch tmux as default
#case $TERM in
#        screen|tmux-256color);;
#        *)tmux att -t 0 2>/dev/null|| tmux;;
#esac;

# Add wisely, as too many plugins slow down shell startup.
plugins=(fastfile copyfile vscode extract docker zsh-autosuggestions git nmap terraform sudo themes encode64 python zsh-syntax-highlighting)

# Here to disable oh-my-zsh auto update
DISABLE_AUTO_UPDATE="true"
source $ZSH/oh-my-zsh.sh

#this alias to make the pc talk
alias tlk="espeak -v en+m3 -s 150" # -v en+m3 -s 150" ==> those are optional

#this function for tlk alias
function tlk1(){
  espeak "$1" && cv;
}

#this alias to clear
alias c="clear"

#this alias to break a line
alias br="br"

#this function for br alias
function br(){
  if [[ $# -eq 1 ]]; then
    for ((i=1; i<=$1; i++)); do
      echo -e;
    done
  elif [[ $# -eq 0 ]]; then
    echo -e;
  fi
}

# This alias to give sudo
# access before command execution
alias allow_sudo="allow_sudo"

# this function for allow_sudo alias
function allow_sudo(){
  # A simple trick is just to clear
  # the screen, clever ain't it ?
  c && br 2
  sudo clear && return 0 || return 1
  # In case of wrong sudo password
  # Don't execute the following command
}

# this alias to ping a network
alias reach="allow_sudo && reach"

#this function to check if pfsense is reachable
# coded 01/29/2024
function reach(){
  local target_IP="$1"
  local check_message="Checking $target_IP reachability..."
  local check_IP="sudo ping -c 1 -W 5 "
  local reachable="br && echo ' $check_message' && eval $check_IP $target_IP &> /dev/null;"
  # the -c 1 means we send one packet to test it
  # the -W 5 means if the ping have 5 seconds to check
  # as always we run it in background in order to
  # not see all the boring logs messages

  if eval $reachable ;then
    #if PfSense is reachable then
    #we execute the next command after
    #this function calling
    # eval "$@"
    echo " $target_IP is reachable"
  else;
    echo " $target_IP is not reachable"
  fi
}

#this alias to launch tmux
alias tmx="tmx"

#this function for tmx alias
function tmx(){
  #if [[ $(tmux ls | wc -l) -gt 0 ]]; then
  #  tmux rename-session "$(basename "$PWD")"
  #else
  # clear && br
  #fi
  c
}

# this alias to have the current view
# of working directory content using ls
alias cv="cv"

#this function for cv alias
#updated today 01/25/2024 to adjust the title
#when we have more than 50 visible items
function cv() {
  local folder_content="${target:-$PWD}"
  local target="$1"
  local folder_name=$(basename $folder_content)
  local visible_item=$(ls $folder_content | wc -l)
  local total_item=$(ls -a $folder_content | wc -l)
  local hidden_item=$((total_item - visible_item - 2))

  #this function for the header of cv alias
  function show_header(){
    local folder_header
    if [[ $hidden_item -eq 0 ]]; then
      folder_header="total($visible_item)";
    else
      folder_header="visible($visible_item) hidden($hidden_item) total($(($total_item - 2))) ";
    fi
    echo " ■■▶ $folder_name folder content : $folder_header";
  }

  #this function to show the content of the cv
  function show_content(){
    ls "$folder_content";
  }

  #this function to show the cv
  function show_all(){
    c && br;

    if [[ $visible_item -lt 50 ]]; then
      show_header;
      br;
      show_content;
      br;
    else
      show_content;
      br 2;
      show_header;
      br;
    fi
  }
  show_all;
}

#this alias to view the current directory content
alias cvf="cvf"

#this function for cvf alias
#updated today 01/25/2024 to adjust the title
#when we have more than 50 visible items
function cvf() {
  local folder_content="${target:-$PWD}"
  local target="$1"
  local folder_name=$(basename $folder_content)
  local visible_item=$(ls $folder_content | wc -l)
  local total_item=$(ls -a $folder_content | wc -l)
  local hidden_item=$((total_item - visible_item - 2))

  #this function for the header of cv alias
  function show_header(){
    local folder_header
    if [[ $hidden_item -eq 0 ]]; then
      folder_header="total($visible_item)";
    else
      folder_header="visible($visible_item) hidden($hidden_item) total($(($total_item - 2))) ";
    fi
    echo " ■■▶ $folder_name folder content : $folder_header";
  }

  #this function to show the content of the cv
  function show_content(){
    ls -a $folder_content;
  }

  #this function to show the cv
  function show_all(){
    c && br;

    if [[ $hidden_item -lt 50 ]]; then
      show_header;
      br;
      show_content;
      br;
    else
      show_content;
      br 2;
      show_header;
      br;
    fi
  }
  show_all;
}


#this alias as default init of command
alias cmt="cmt"

#this alias to clear but with extra lines
alias x="clear && br 4"

#this alias to exit
alias q='q'

#this function is for q alias
function q(){
  if [[ $hack -eq 1 ]]; then
    qh && exit
  else
    exit
  fi
}

#this alias to give full permission
alias all="all"

#this function for all alias
function all(){
  if [[ $# -eq 0 ]]; then
    chmod 777 * && cv;
  else
    chmod 777 "$@" && cv;
  fi
}

#this function for all alias
#function all(){
  #if [[ $# -eq 0 ]]; then
 # arg='[[ $# -eq 0 ]]'
 # chmod 777 "$(eval "$arg" && echo "$@" || echo "*")";
  #else
    #chmod 777 "$@";
  #fi
  #cv;
#}

#this alias to reload the zshrc file
alias rld="rld"

#this function for rld alias
function rld(){
  clear;
  source ~/.$(basename $SHELL)rc;
  local saved_file="zshrc[$USER]"
  cat ~/.zshrc > ~/NTSOA/zsh_config/linux/$saved_file;
  all ~/NTSOA/zsh_config/linux/$saved_file;
  c && br;
  echo "z s h    s a v e d " | figlet -t -c;
  # tlk "saved";
  br && sleep 0.5;
  op /home/h471x/NTSOA/zsh_config;
}

#this alias to show the welcome message
alias cvi="cvii"

#here to write a welcome message
function cvii(){
  clear;
  br 2;
  #cat ~/Desktop/logo.txt;
  echo "H    4    7    1    X" | figlet -t -c;
  br 2;
}

#call the followinf alias at startup
#clear && echo -e && echo -e && echo -e && echo -e && echo -e && echo -e && echo -e && echo -e
# clear && cvi
clear && x;
# sleep 0.5;
# if [[ $# -eq 0 ]]; then
#   cvi
# fi

# call the cv alias whenever a wrong
# command is typed which doesn't surely exist
command_not_found_handler() {
  local command=$1
  local command_found=0

  # Check if the command is found in the .zshrc file
  if grep -q -E "^alias $command=" "$HOME/.zshrc" ; then
    command_found=1
  fi

  if [[ $command_found -eq 0 ]]; then
    # c && br && echo "n o t     f o u n d " | figlet -t -c | lolcat;
    # br && sleep 0.5 && cv;
    # cv;
    # echo "fuck, wrong command"
    echo "${BOLD}${WHITE}[${RED}x${WHITE}]${WHITE} Command Not Found "
    # fuck
  fi
}

#press the button alt twice to call cv
#zle -N cv
#bindkey ^²' cv

#this alias to view the current directory content with specifications
alias cvg="cvg"

#this function for cv alias
function cvg(){
  c && br;
  if [[ $# -eq 1 ]]; then
    echo "   $(basename "$PWD") folder content with "$1" : ";
    br && ls | grep "$1" && br;
  elif [[ $# -eq 0 ]]; then
    cv;
  fi
}

#this alias to open a directory
alias op="op"

#this function for op alias
function op(){
  if [[ -d "$1" ]]; then
    if [[ "$#" -eq 1 ]]; then
      cd "$1"; cv;
    elif [[ "$#" -eq 2 ]]; then
      cd "$1"; cvg "$2";
    fi
  elif [[ -f "$1" ]]; then
    vf "$1"
  fi
}

#this alias to open directory with the default file explorer, here we use Thunar
alias exop="exop"

#this function for exop alias
function exop(){
  #thunar "${1:-.}";
  xdg-open "${1:-.}"
  cv;
}

#here to launch tmux and cv after 1 second
#sleep 1 && tmux && cv


#this alias to enter the zshrc file
alias ct='nvim ~/.zshrc; cv;'

# this alias to count the number of file/directory
# inside a directory
alias dc="dc"

#this function for dc alias
function dc(){
  if [[ $# -eq 0 ]]; then
    clear;
    br;
    case "$(ls -1 | wc -l)" in
      0)
        br;
        echo "There is nothing inside $(basename $PWD)";
        br;;
      *)
        case "$(ls -1 | wc -l)" in
          1)it="item";;
          *)it="items";;
        esac
        echo "   $(basename $PWD) folder has $(ls -1 | wc -l) $it : ";
        br;
        if [[ $(ls -1 | wc -l) -gt 50 ]]; then
          br;
        else
          ls
        fi
        br;
    esac
  elif [[ $# -eq 1 ]]; then
    clear;
    br;
    case "$(ls -1 $1 | wc -l)" in
      0)
        br;
        echo "There is nothing inside $(basename $1)";
        br;
        sleep 1;
        cv;
        br;;
      *)
        case "$(ls -1 $1 | wc -l)" in
          1)it="item";;
          *)it="items";;
        esac
        echo "   $(basename $1) folder has $(ls -1 $1 | wc -l) $it : ";
        br;
        if [[ $(ls -1 "$1" | wc -l) -gt 50 ]]; then
          br;
        else
          ls "$1";
        fi
        br;
        sleep 1;
        cv;
    esac
  fi
}

#this line to count line and words inside a file
alias flc="flc"

#this function for the cl alias
function flc(){
  if [[ -f "$1" ]]; then
    if [ -z "$1" ]; then
      echo "Please provide a filename"
    elif [ -z "$2" ]; then
      c && br;
      #echo file info" | figlet -t -c -f mono12;
      echo -ne " ==> "
      file "$1";
      echo -ne " ==> ";
      wc -l "$1" | awk '{print $1, "lines"}';
      echo -ne " ==> ";
      wc -w "$1" | awk '{print $1, "words"}';
      br;
    else
      grep -c "$1" "$2" | awk -v var="$1" '{print $1, var, "in it"}'
    fi
  elif [[ -d "$1" ]]; then
    dc "$1";
  fi
}

#this alias to know the file type
alias tp="tp"

#this function for tp alias
function tp(){
  type=$(ls -ld "$1" | cut -c1)
  case $type in
    -) echo "Fichier normal" ;;
    d) echo "Repertoire" ;;
    b) echo "mode bloc" ;;
    l) echo "lien symbolique" ;;
    c) echo "mode caractere" ;;
    *) echo "autre" ;;
  esac
}


#this alias to view the pictures folder
alias pct="pct"

#this function for pct alias
function pct(){
  op /home/h471x/Pictures;
}

#this line to directly go to JPG version of the time schedule
alias ej="c && op /home/h471x/NTSOA/EDT\ ENI/JPG/L2\ 2024"

#commented for I don't use it 09/14/2023 

#this alias to copy the edt file to the usb
#alias edc="edc"

#this function for edc alias
#function edc(){
#  usb_in="lsblk | grep /media/h471x/PXL\ USB"
#  usb_connected=$(eval "$usb_in")
#  if [ -n "$usb_connected" ]; then
#    if [[ -f /media/h471x/"PXL USB"/"EDT ENI"/"$1" ]]; then
#      op /media/h471x/"PXL USB"/"EDT ENI";
#    else
#      cp "$1" /media/h471x/"PXL USB"/"EDT ENI" && op /media/h471x/"PXL USB"/"EDT ENI";
#    fi
#  else
#    br 2;
#    echo "Please connect the USB device if you want to copy the EDT file !";
#    br;
# fi
#}

#this alias to convert the time schedule in pdf to jpg
alias ei="ei"

#this function for ei alias
function ei(){
  # useful variables
  local input_pdf="$1"
  local output_image="$(basename "$input_pdf" .pdf).jpg";
  local kali_edt_path=/home/h471x/NTSOA/EDT\ ENI/JPG/L2\ 2024;
  local windows_edt_path=/media/sf_ENI/ENI\ 2024/0\ EDT/L2\ 2024

  # convert pdf to jpg using imagemagick convert
  convert -density 500 "$input_pdf" "$output_image";

  # full access to the files
  all "$input_pdf";
  all "$output_image";

  # moving to the right directories
  cp "$output_image" $windows_edt_path;
  mv "$output_image" $kali_edt_path;

  # Success message
  c && br 2;
  echo "${GREEN}${BOLD} ==> SUCCESS ${WHITE}"
  br;
  echo "${BOLD} $input_pdf -> $output_image ${RESET}";
  br;
  sleep 3;

  # open the edt list
  op $windows_edt_path;
}

#this alias to edit the time schedule
alias edt="edt"

#this function for edt alias
function edt(){
  cd /home/h471x/NTSOA/'EDT ENI'/ODS;
  op "EDT ENI L2 2024.ods"
  op /home/h471x/NTSOA/'EDT ENI'/PDF;
}

#this alias to view the time schedule
alias edt="edtv"

#this function for edt alias
function edtv(){
  op /home/h471x/NTSOA/'EDT ENI';
}

#this alias to open a directory and make it as destination
alias opd="opd"

#this function for opd alias
function opd(){
  op "$1" && dt && nd;
}

#this alias to run an executable file or a script
alias rn="rn"

#this function for rn alias
function rn(){
  #this will look for the extension of the file
  case "${1##*.}" in
    py)
      if [[ $# -eq 1 ]]; then
        all "$1";
        c && br;
        python3 "$1";
        br;
      elif [[ $# -gt 1 ]]; then
        all "$1";
        c && br;
        python3 "$1" "$@";
        br;
      fi
    ;;
    c || cpp) #update 07/28/2023
      file="$1";
      out="${file%.*}"

      # Condition 1: Check if the file extension is c
      extension='[[ "${file##*.}" == "c" ]]';

      # Condition 2: Check if the file contains math library
      math='grep -E "^#include <math.h>" "$file" >/dev/null';

      # check if an old executable exist
      # exist=[[ -f ${file%.*}" ]]';

      # Ternary expressions to determine compiler and flags
      compiler=$(eval "$extension" && echo "gcc" || echo "g++");
      flags=$(eval "$math" && echo "-lm" || echo "");
      # check=$(eval $exist" && echo dlf $out);

      # Check if an old executable exists
      if [[ -f "$out" ]]; then
        dlf "$out";
      fi

      # Compile the C file
      "$compiler" "$file" -o "$out" $flags;

      # Execute the resulting executable
      all "$out";
      clear && br;
      ./"$out";
      br;;
    html)
      google-chrome "$1" && cv;;
    asm)
      nasm -felf64 "$1"
      ld ${1%.*}.o -o ${1%.*}
      ./${1%.*}
      ;;
    *)
      all "$1" && c && ./"$1";;
 esac
}

#this alias to serve files via the Php server
alias srv="srv"

#this function for srv alia
function srv(){
  php -S 127.0.0.1:50000;
  google-chrome 127.0.0.1:50000/"$1";
}

#this alias to update the package
alias upd="allow_sudo && upd"

#this function for up alias
function upd(){
  echo "u p d a t i n g .  .  ." | figlet -t -c;
  br && sudo apt update && br;
}

#this alia to update the package
alias upg="allow_sudo && upg"

#this function for up alias
function upg(){
  echo "u p g r a d i n g . . ." | figlet -t -c;
  br && sudo apt upgrade && br;
}

#this alias to install package
alias ist="allow_sudo && ist"

#this function for ist alias
function ist(){
  case "${1##*.}" in
    git)
      clear && br 2;
      echo "   C l o n i n g .  .  . " | figlet;
      br;
      echo "Package =======> "${1%.*}" ";
      br;
      git clone "$1";
      br;;
    deb)
      br 2;
      echo "   I n s t a l l i n g .  .  . " | figlet;
      br;
      echo "Package =======> "${1%.*}" ";
      br;
      sudo dpkg -i "$1";
      br;;
    *)
      c && br 2;
      sudo clear;
      br 2;
      echo "   I n s t a l l i n g .  .  . " | figlet;
      br;
      echo "Package =======> "$1" ";
      br;
      sudo apt install "$1";
      br;;
  esac
}

#this alias to install package
alias rmv="allow_sudo && rmv"

#this function for ist alias
function rmv(){
  case "${1##*.}" in
    deb)
      echo "   r e m o v i n g .  .  . " | figlet | lolcat;
      br;
      echo "Package =======> "${1%.*}" ";
      br;
      sudo dpkg -r "$1";
      br;
      ;;
    *)
      br 2;
      echo "   r e m o v  i n g .  .  . " | figlet | lolcat;
      br;
      echo "Package =======> "$1" ";
      br;
      sudo apt remove "$1";
      br;
      ;;
    esac
}

#this alias to connect to a ssh server
alias cns="cns"

#this function for cns alias
function cns(){
  if [[ $# -eq 0 ]]; then
    c && echo -e && echo -e && sudo clear && echo -e && echo -e && echo "s s h    l o g i n" | figlet -t -c | lolcat && echo -e && echo -ne " User : " && read user && echo -ne " IP adress : 192.168." && read ip1 && clear && echo -e && echo -e && echo "s s h    l o g i n" | figlet -t -c | lolcat && echo -e && echo " User : "$user"" && echo -ne " IP Adress : 192.168."$ip1"."&& read ip2 && echo -e && echo " Connection to <"$user"> 's ssh server at <192.168."$ip1"."$ip2"> adress !! " && echo -e && ssh $user@192.168.$ip1.$ip2 && echo -e;
  elif [[ $1 -eq '-a' ]]; then
    c && echo -e && echo -e && sudo clear && echo -e && echo -e && echo "s s h    l o g i n" | figlet -t -c | lolcat && echo -e && echo -ne " User : " && read user && echo -ne " IP adress : 192.168." && read ip && echo " Port : 8022" && echo -e && echo " Connection to <"$user"> 's ssh server at <192.168."$ip"> adress !! " && echo -e && ssh $user@192.168.$ip -p 8022 && echo -e;
  elif [[ $1 -eq '-i' ]]; then
    c && echo -e && echo -e && sudo clear && echo -e && echo -e && echo "s s h    l o g i n" | figlet -t -c | lolcat && echo -e && echo -ne " User : " && read user && echo -ne " IP adress : " && read ip3 && echo -e && echo " Connection to <"$user"> 's ssh server at <"$ip3"> adress !! " && echo -e && ssh $user@$ip3 && echo -e;
  fi
}

##this alias to view inside a file
#alias vf="vf"
#
##this function for vf alias
#function vf(){
#  #detects if the argument is a file
#  if [[ -f "$1" ]]; then
#    case "${1##*.}" in
#      JPG || jpg || ico || png)
#        ristretto "$1" && cv;;
#      pdf)
#        atril "$1" && cv;;
#      cap || pcapng)
#        wireshark "$1" && cv;;
#      csv || ods || xlsx)
#        xdg-open "$1" && cv;;
#      mp*)
#        vlc "$1" && cv;;
#      gz || rar)
#        engrampa "$1" && cv;;
#      html || c || cpp || tf || py || java || js || css || json)
#        code "$1" && cv;;
#      *)  
##same condition but using the case statement
#case "$#" in
#  1)nvim "$1" && cv;;
#  #1)cat "$1" | less && cv;;
#  2)cat "$1" | grep "$2" | less && cv;;
#  *)cv;;
#esac;;
#    esac
#  elif [[ -d "$1" ]]; then
#    op "$1" && cv;
#  fi
#}
#

# Alias to view inside a file
alias vf="vf"

# Function for vf alias
# update 09/14/2023
function vf() {
  local file="$1"
  # xdg-open $file;
  local extension="${file##*.}"
  #
  # # here if you don't know the default app,
  # # use xdg-open instead of those cmd
  #
  case "$extension" in

  # jpg|jpeg|ico|png)
  #     cmd="eog";;
  #   pdf)
  #     cmd="evince";;
  #   cap|pcapng)
  #     cmd="wireshark";;
  #   csv|ods|xlsx)
  #     cmd="xdg-open";;
  #   mp*)
  #     cmd="vlc";;
  #   gz|rar)
  #     cmd="engrampa";;
  #   html|c|cpp|tf|py|java|js|css|json)
  #     cmd="code";;
    mcd)
      cmd="katyushamcd";;
    *)
      cmd="xdg-open";;
  esac
  #
  # if [[ -f "$file" ]]; then
    "$cmd" "$file" && cv
  # elif [[ -d "$file" ]]; then
  #   op "$file" && cv
  # fi
}

#this alias to view binary file
alias vfb="vfb"

#this function for vfb alias
function vfb(){
  # if [[ -x "$1" ]]; then
  #   xxd -b "$1" | xargs echo | xxd -r -p | nvim -
  # else
  #   echo "The file $1 is not a binary file."
  # fi
  od -t x1 -A n "$1";
}

#this alias to rename a file / directory; and display it after
alias nm="nm"

#this function for nm alias
function nm(){
  mv "$1" "$2" && cv;
}

#this alias to enter the manual directory
alias mnv="mnv"

#this function for mnv alias
function mnv(){
  if [[ $# -eq 0 ]]; then
    op /home/h471x/NTSOA/manual;
  elif [[ $# -eq 1 ]]; then
    op /home/h471x/NTSOA/manual "$1";
  fi
}

#this alias to view tthe manual entry for a command
alias mns="mns"

#this function for mn alias
function mns(){
  if [[ $(command -v "$1") ]]; then
    #here to check if the command exists
    man "$1" | cat > ~/NTSOA/manual/"$1".txt;
    all ~/NTSOA/manual/"$1".txt;
    nvm ~/NTSOA/manual/"$1".txt;
    cv;
  else
    c && br;
    echo "n o t     f o u n d " | figlet -t -c | lolcat;
    br && sleep 0.5 && cv;
  fi
}

#this line to count line inside a file
alias cl="linecount"

#this function for the cl alias
function linecount() {
  if [ -z "$1" ]; then
    echo "Please provide a filename"
  elif [ -z "$2" ]; then
    wc -l "$1" | awk '{print $1, "lines"}'
  else
    grep -c "$1" "$2" | awk -v var="$1" '{print $1, var, "in it"}'
  fi
};

#this line to view a command manual
alias mn="mn"

#this function for mn alias
function mn(){
  if [[ $# -eq 1 ]]; then
    man $1 | less
  else
    man $1 | grep $2 | less
  fi
}

#this alias to edit a file
alias ed="ed"

##this function for ed alias
function ed(){
  nvim -c "startinsert" "$1" && cv;
}

#this alias to open the current directory inside neovim
alias nvm="nvm"

#this function for nvm aliases
function nvm(){
  nvim "${1:-.}";
  cv;
  #if we have one argument then nvim will be launched with it,
  #otherwise open the current directory if there is no argument
}

# this alias to open nvim as root
alias nvmr="allow_sudo && nvmr"

# this function for nvmr alias
function nvmr(){
  sudo nvim "${1:-.}"
  cv
}

#this alias is the same as ed but it uses nano instead of nvim
alias edn="edn"

#this function for edn alias
function edn(){
  nano "$1";
  if [[ -f "$1" ]]; then
    all "$1" && cv;
  else
    cv;
  fi
}

#this alias to go back from a directory
alias b="b"

#this function for b alias
function b(){
  if [[ $# -eq 0 ]]; then
    cd ..; cv;
  else
    for ((i=1; i<=$1;i++)); do
      cd ..; cv;
    done
  fi
}

#this alias to go to the previous directory
alias nd="nd"

#this function for nd alias
function nd(){
  cd -; cv;
}

#this alias to switch to root
alias ad="ad"

#this function for ad alias
function ad(){
  c && echo -e && echo -e && sudo su && cv;
}

#this alias to simulate the sudo behaviour
alias hndo="hndo"

#this function for hndo alias
function hndo(){
  local attempts=3
  local expected_password="test"

  c && br 2

  while [ $attempts -gt 0 ]; do
    echo -ne "Your Password, Sir : "
    read -s password

    if [ "$password" = "$expected_password" ]; then
      c && br
      return 0
    else
      attempts=$((attempts - 1))
      br
      echo -n "Wrong, Try Again"
      # tlk "Incorrect"
      # br
      # echo "$attempts remaining"
      br
      if [ $attempts -gt 0 ]; then
        continue
      else
        echo "hndo: 3 incorrect password attempts"
        return 1
      fi
    fi
  done
}

#this alias to enter the devops course
alias dvps="op /home/h471x/NTSOA/COURSE/DEVOPS/NOTES "

#this alias to view the aws informations
alias awsd="op /home/h471x/NTSOA/COURSE/DEVOPS/AWS "

#this alias to go to the ENI folder
alias eni="op /home/h471x/NTSOA/COURSE/ENI"

#this alias to go to the to desktop
alias dtp="op /home/h471x/Desktop"

#this alias to go to the to dev
alias dev="op /home/h471x/NTSOA/dev"

#this alias to open the text notes
alias nt="op /home/h471x/NTSOA/notes"

#this alias to open HTX USB
alias htx="op /media/h471x/HTX\ USB"

#this alias to open PXL USB
# alias pxl="op /media/h471x/PXL\ USB"

#this alias to create a file
alias tf="tf"

#this function for tf alias
function tf(){
  touch "$@" && all "$@" && cv;
}

#this alias to delete file
alias dlf="dlf"

#this function for dlf alias
function dlf(){
  rm "$@" && cv;
}

#this line to have destination location for copy / cut
alias dt="dt"

#this function for dst alias
function dt(){
  dest="$PWD" && c && br;
  echo "d e s t   s a v e d" | figlet -t -c;
  sleep 0.6 && cv;
}

#this alias to copy the absolute path of the current directory to the clipboard
alias dl="dl"

#this function for dl alias
function dl(){
  # pwd | tr -d "\n" | pbcopy
  pwd | tr -d "\n" | xclip -selection clipboard
  c && br;
  echo "p a t h   s a v e d" | figlet -t -c | lolcat;
  sleep 0.6 && cv;
}

#this alias to copy a file then display it
#alias cpf="cpf"

#this function for cpf alias
#function cpf(){
 # if [[ $# -eq 2 ]]; then
 #   if [[ -d "$1" ]]; then
 #     #here to check if the first argument is a directory
 #     cp -r "$1" "$2" && op "$2" && all "$1";
 #   else
 #     cp "$1" "$2" && op "$2" && all "$1";
 #   fi
 # elif [[ $# -eq 1 ]]; then
 #   if [[ -d "$1" ]]; then
 #     #here to check if the first argument is a directory
 #     cp -r "$1" "$dest" && op "$dest" && all "$1";
 #   else
 #     cp "$@" "$dest" && op "$dest" && all "$@";
 #   fi
 # fi
#}

#this alias to copy files
alias cpf="cpf"

#this function for cpf alias
function cpf(){
  local copy_target=${2:-$dest}
  cp -r "$@" "$copy_target" && op "$copy_target";
}

function cpf2() {
  cp "${@:1:$#-1}" "${@:$#}";
}

#this alias to move files
alias mvf="mvf"

#this function for cpf alias
function mvf(){
  local move_target=${2:-$dest}
  mv "$@" "$move_target" && op "$move_target";
}

function cpf2() {
  cp "${@:1:$#-1}" "${@:$#}";
}


#this alias to copy the content of a file
alias cnf="cnf"

#this function for cnf alias
function cnf(){
  cat "$1" > "$2" && dlf "$1" && all "$2";
}

#this alias to copy a file then display it
#alias mvf="mvf"

#this function for cpf alias
#function mvf(){
  #if [[ $# -eq 2 ]]; then
   # mv "$@" "$2" && op "$2";
  #elif [[ $# -eq 1 ]]; then
  #  mv $@ $dest && op $dest;
    #if there is only one argument, it will move the file
    # or directory to the the variable dest defined
    # in dt alias
 # fi
#}

#this alias to create a directory
alias drc="drc"

#this function for dr alias
function drc(){
  mkdir "$@" && cv;
}


#this alias to create a directory
#and then directly enter to it
alias opdr="opdr"

#this function for opdr alias
function opdr(){
  drc "$1" && op "$1";
}

#this alias to remove a directory
alias rd="rd"

#this function for rd alias
function rd(){
  rm -r "$@" && cv;
}

#this alias to force delete
alias rdf="rdf"

#this function for rdf alias
function rdf(){
  clear && br 2 && sudo clear && sudo rm -rf "$@" && cv;
}

#this alias to view the usb device connected here
alias usb="op /media/h471x"

#this alias to open the shared folder
alias sf="op /media/sf_ENI_2023"

#this alias to view the pc state
alias pc="c && br 2 && neofetch --source ~/.config/neofetch/hn.txt"

#call this pc alias at startup
#pc

#this alias to go to home directory
alias hm="cd && cv"

#this alias to access / directory
alias rt="cd / && cv"

#this alias to enter the NTSOA directory
alias hn="op ~/NTSOA"

#this alias to go to the download folder
alias dwl="op /home/h471x/Downloads"

#this alias to open the HACK directory
alias hack="op /home/h471x/NTSOA/hack"

#this alias to open the ENI CYBERSECURITY directory
alias cs="op /home/h471x/NTSOA/ENI\ CYBERSECURITY"

#this alias to view the history
alias hst="hst"

# this function for hst alias
function hst(){
  if [[ $# -eq 0 ]]; then
    history | less && cv
  else
    re='^[0-9]+$'
    if [[ $1 =~ $re ]]; then
      # check if the argument is an integrer
      history | tail -$1 | less && cv
    else
      # else if it's a text to grep
      history | grep "$1" | less && cv
    fi
  fi
}

# this alias to open the shareed folder
alias kali="op /media/sf_KALI_LINUX"

# this alias to open the books shared folder
alias books="op /media/sf_BOOKS"

# this alias to open ENI shared folder
alias eni="op /media/sf_ENI/ENI\ 2024"


#this alias to locate packages
alias lc="lc"

#this function for lc alias
function lc(){
  locate "$1" | less && cv;
}

#this alias to save a history into a txt file
#alias hsv="hsv"

#this function for hsv alias
#function hsv(){
 # spec=${echo "$1 | grep $2":- echo "$1"};
 # dest=${echo "$2.txt":-echo "history_save.txt"};
 #  history $spec > $dest;
#}

#this alias to specify which command in the history to search
alias hsg="hsg"

#this function for hsg alias
function hsg(){
  if [[ $# -eq 0 ]]; then
    history | less && cv;
  else
    history | grep "$1" | less && cv;
  fi
}

#this alias to call tmux
alias tx="c && tmux && cv"

#this alias to give a hacker look to the terminal
alias hck="hck"

#this function to set and unset hackmode using a single alias
function hck(){
  if [[ $(tmux ls | wc -l) -gt 0 ]]; then
    if [[ $hack -eq 0 ]]; then
      hack1
      hack=1
    else
      qh
      hack=0
    fi
  else
    tx
  fi
}

#set the hack variable to 0 at startup
hack=0

#this function for hck alias
function hack1(){
  tmux split-window -h "htop" && tmux select-pane -L;
  tmux split-window -v "cmatrix" && tmux select-pane -U;
  c && br 6;
  echo '   h a c k     m o d e ' | figlet | lolcat;
  br 2 && tlk "Hack Mode" && sleep 0.5 && pc
}

#this alias to quit hack mode
alias qh="qh"

#this function for qh alias
function qh(){
  hack=0 && tmux select-pane -D && tmux kill-pane && tmux select-pane -R && tmux kill-pane && c && echo -e && echo -e && echo -e && echo -e && echo -e && echo -e && echo '        N o r m a  L   ' | figlet | lolcat && tlk "Hack mode disabled" && cv
}

#this alias to show the network configuration
alias ipsh="ipsh"

#this function for ntsh alias
function ipsh(){
  c && br;
  echo "  Available IP Adresses : ";
  br;
  # ifconfig wlan0;
  # br;
  local eth_ip=$(ifconfig eth0 | grep "inet " | awk '{print $2}');

  # Add a conditon to make it view
  # IP from interface passed as argument
  if [[ $# -eq 1 ]]; then
    local iface_ip=$(ifconfig "$1" | grep "inet " | awk '{print $2}');
    echo " $1 ==> $iface_ip";
  else
    if [ -d /sys/class/net/wlan0 ]; then
      local wlan_ip=$(ifconfig wlan0 | grep "inet " | awk '{print $2}');
      echo " wlan0 ==> $wlan_ip";
      echo " eth0  ==> $eth_ip" && br;
    else
      echo " eth0 IP ==> $eth_ip" && br;
    fi
  fi

  # ifconfig | awk -F '[ :]+' '/^[a-z]/ {interface=$1} /inet / {print interface " ==> " $3}'
}

#this alias to list the local IP adresses
alias ipls="ipls"

#this function for ipls alias
function ipls(){
  c && br;
  echo "   Local Devices IP Adresses : ";
  br;
  arp -e;
  br;
}

#this alias to show the network configuration
alias ntsh="ntsh"

#this function for ntsh alias
function ntsh(){
  c && br;

  if [ -d /sys/class/net/wlan0 ]; then
    echo "      Wireless Network informations : ";
    if [[ $# -eq 0 ]]; then
      br;
      iwconfig wlan0 | grep "Mode" | awk -F ":" '{print $2}' | grep M | awk '{print "wlan0 Mode ==> " $1}';
      br;
    elif [[ $# -eq 1 ]]; then
      br && iwconfig "$1" && br;
    fi
  else
    echo "No Wireless adapter found" && br;
  fi
}

#this alias to define the type of the wireless adapter
alias wtp="wtp"

#this function for wtp alias
function wtp(){
  if [[ $# -eq 2 ]]; then
    sudo ip link set "$1" down;
    sudo iw "$1" set type "$2";
    sudo ip link set "$1" up;
  else
    c && br 2;
    echo "Invalid Argument" | figlet -t -c;
    br;
  fi
}


#this alias to scan wifi
alias scn="scn"

#this function for scn alias
function scn(){
  c && br 2 && sudo clear;
  wtp wlan0 monitor;
  br 2;
  echo "s c a n n  i n g . . ." | figlet -t -c | lolcat;
  sleep 1;
  sudo airodump-ng wlan0;
  wtp wlan0 managed;
  br;
}

#this function to kill process
function kl(){
  if pgrep -f "$1">/dev/null; then
    sudo kill $(pgrep "$1");
  fi
}

#this alias to switch to monitor mode
alias mntr="mntr"

#this function for mntr alias
function mntr(){
  c && br 2;
  sudo clear;

  if [ -d /sys/class/net/wlan0 ]; then
    c && br 2 && sudo clear;
    kl NetworkManager;
    kl wpa_supplicant;
    kl dhclient;
    sudo airmon-ng start wlan0 && c;
    echo "M o n i t o r" | figlet -t -c;
    sleep 0.5;
    br;
  else
    br 2;
    echo "No wireless adapter";
    br;
  fi

}

#this alias to set the network adapter to monitor mode
#in another way
alias rmon="rmon"

#this function for rmn alias
function rmon(){
  c && br 2 && sudo clear;
  sudo airmon-ng check wlan0;
  c;
  sleep 1;
  sudo airmon-ng check kill wlan0;
  c;
  sleep 1;
  sudo airmon-ng start wlan0;
  c;
  echo "M o n i t o r     M o d e" | figlet -t -c | lolcat;
  sleep 1;
  c && br;
  ntsh;
}

#this alias to switch to managed mode
alias mngd="mngd"

#this function for mngd alias
function mngd(){
  c && br 2 && sudo clear;
  wtp wlan0 managed;
  br 2;
  echo "M a n a g e d     M o d e" | figlet -t -c | lolcat;
  tlk "managed mode";
  sleep 0.5;
  c && br;
  ntsh;
}

# this alias to restart the network manager after a hack
alias rst="rst"

# this function for rst alias
function rst(){
  c && br 2 && sudo clear && br;
  sudo service NetworkManager restart;
  br 2;
  echo "N e t     R e s e t" | figlet -t -c;
  # tlk "network reset";
  sleep 1;
  sudo service NetworkManager restart;
  upnet eth0;
  #upnet eth1;
  if [ -d /sys/class/net/wlan0 ]; then
    upnet wlan0;
    wtp wlan0 managed;
    sleep 0.5;
  fi
  cv;
}

# ANSI CODES ARIABLES
# Text
RESET="$(printf '\033[0m')"
BOLD="$(printf '\033[1m')"
RED="$(printf '\033[31m')"
GREEN="$(printf '\033[32m')"
ORANGE="$(printf '\033[33m')"
YELLOW="$(printf '\033[33m')"
BLUE="$(printf '\033[34m')"
BRIGHT_BLUE="$(printf '\033[94m')"
MAGENTA="$(printf '\033[35m')"
CYAN="$(printf '\033[36m')"
#WHITE="$(printf '\033[37m')"
WHITE="$(printf '\e[97m')"
BLACK="$(printf '\033[30m')"
NC="$(printf '\033[0m')" #Reset colour
#Background
REDBG="$(printf '\033[41m')"
GREENBG="$(printf '\033[42m')"
ORANGEBG="$(printf '\033[43m')"
BLUEBG="$(printf '\033[44m')"
MAGENTABG="$(printf '\033[45m')"
CYANBG="$(printf '\033[46m')"
WHITEBG="$(printf '\033[47m')"
BLACKBG="$(printf '\033[40m')"
RESETBG="$(printf '\e[0m\n')" #Reset background

# Character
CHECKMARK="$(printf '\xE2\x9C\x94')"
QUESTION_MARK="$(printf '\xE2\x9D\x93')"

# this alias to run wifite
alias whk="allow_sudo && whk"

# this function for whk alias
function whk(){
  function hack_wifi(){
    sudo wifite --kill;
    br;

    # this function will ask if the
    # hacking should restart or not
    function check_quit(){
      echo -ne " ${WHITE}[${GREEN}?${WHITE}]${WHITE} ${GREEN}Restart ${WHITE}the wifi hacking ? (y/n) ";
      read wifi
      if [ "$wifi" = "y" ]; then
        whk
      elif [[ "$wifi" = "n" ]]; then
        echo -ne " ${WHITE}[${GREEN}+${WHITE}]${WHITE} Switching to ${GREEN}Managed ${WHITE}Mode  ";
        downnet eth0 && upnet wlan0;
        wtp wlan0 managed;
        echo "${GREEN}$CHECKMARK${WHITE}"
        echo -ne " ${WHITE}[${GREEN}+${WHITE}]${WHITE} Restarting Network Manager "
        sudo service NetworkManager restart;
        echo "${GREEN}$CHECKMARK${WHITE}"
      else
        check_quit
      fi
    }
    check_quit
  }

  if [ -d /sys/class/net/wlan0 ]; then
    hack_wifi
  else
    br
    echo "  ${BOLD}${WHITE}[${RED}x${WHITE}]${WHITE} No ${RED}Wireless Card ${WHITE}Available"
    br
  fi
}

# this alias to create a Fake Access Point
alias facp="facp"

# this function for facp alias
function facp(){
  c && br 2 && sudo clear;
  sudo airbase-ng --essid "HTX AP" -c 11 wlan0;
}

# this alias to deauth wireless connection
alias deauth="deauth"

# this function for deatuh alias
function deauth(){
  if [[ $# -eq 1 ]]; then
    if [ -d /sys/class/net/wlan0 ]; then
      c && br 2 && sudo clear;

      if [[ !$(pgrep NetworkManager) ]]; then
        sudo systemctl start NetworkManager;
        wtp wlan0 managed;
      fi
  
      # kl wpa_supplicant;
      # kl dhclient;

      echo "        D e A u t h" | figlet && br;
      echo " ==> Target Wi-Fi : $1 " && br;
      ssid="$1"
      bssid=$(nmcli -f BSSID,SSID device wifi list | grep "$ssid" | awk '{print $1}')
      # bssid=$(sudo iw dev wlan0 scan | grep -B 8 "SSID: $ssid" | awk -F "(" '/^BSS/{print $1}' | tr '[:lower:]' '[:upper:]' | sed 's/BSS //');
      # here we use the iw dev wlan0 scan to show the wireless networks without using nmcli
      # the grep -B 8 means it will match the eight's line before the found on the pattern
      # use grep -A to match lines after the matched one
      # awk -F "" will set the delimiter between matches and then it will print the first side of the matching pattern 
      # tr will then convert all the letter to uppercase
      # the sed 's/BSS //' will replace BSS to nothing
      # what can I say, today 11/11/2023 I'm becoming more and more good at pattern matching
      if [ -n "$bssid" ]; then
        # if [[ -n $(sudo airmon-ng check wlan0) ]]; then
        #   sudo airmon-ng check kill wlan0;
        # fi
        sudo aireplay-ng -0 0 -a "$bssid" wlan0;
      else
        echo "SSID '$ssid' not found";
        br;
      fi
    else
      echo "No wireless adapter found";
      br;
    fi
  else
    echo "Please pass the Wi-Fi SSID as the argument";
  fi
}

# this alias to connect to a wifi via CLI
alias wcnt="wcnt"

# this function for wcnt alias
function wcnt(){
  if [[ $# -eq 1 ]]; then
    if [ -d /sys/class/net/wlan0 ]; then
      nmcli device wifi connect "$1";
    else
      echo " No wireless adapter found";
      br;
    fi
  elif [[ $# -eq 2 ]]; then
    if [ -d /sys/class/net/wlan0 ]; then
      nmcli device wifi connect "$1" password "$2";
    else
      echo " No wireless adapter found";
      br;
    fi
  else
    echo "Please pass the Wi-Fi SSID as argument";
  fi
}

# this alias to list all the wifi nearby
alias wls="allow_sudo && wls"

# this function for wls alias
function wls(){
  if [ -d /sys/class/net/wlan0 ]; then
    downnet eth0 && upnet wlan0;
    c && br 2;
    echo " Wi-Fi connections nearby : " && br;
    nmcli -f SSID,BSSID,SECURITY,CHAN,SIGNAL,BARS,RATE,MODE device wifi list
    # nmcli -f SSID,SECURITY,CHAN,SIGNAL,BARS,RATE,MODE device wifi list
    # wait;
    br;
  else
    br 2;
    echo "No wireless adapter";
    br;
  fi
}

# this function to check saved wifi network
function wchk(){
  # Get the saved Wi-Fi connections
  nmcli connection show | grep -q "$1" && echo "$1 found" || echo "$1 not found"
  # We have a cool ternary expression here :D
}

# this alias to run airgeddon
alias rhk="allow_sudo && rhk"

# this function for rhk alias
function rhk(){
  sudo airgeddon
}

# this alias to run the cupp command
alias cupp="cupp"

# this function for cupp alias
function cupp(){
  c && br;
  if [[ $# -eq 0 ]]; then
    cupp.py -i;
  elif [[ $# -gt 0 ]]; then
    cupp.py $@;
  fi
}

# this function to view the current apache2
# service, its status
function stap(){
  if [[ $(pgrep apache2) ]]; then
    c && br;
    echo "${BOLD}Apache Server Active [${GREEN}✓${WHITE}]"
    br;

    local eth_iface="eth0"
    local wifi_iface="wlan0"
    local loopback_iface="lo"
    if [ -d /sys/class/net/wlan0 ]; then
      local wlan_ip=$(ifconfig $wifi_iface | grep "inet " | awk '{print $2}');
      echo "$wifi_iface Interface Connection (Public)  : ${BRIGHT_BLUE}http://$wlan_ip${WHITE}";
    fi
    local loopback_ip=$(ifconfig $loopback_iface | grep "inet " | awk '{print $2}');

    echo "$loopback_iface    Interface Connection (Private) : ${BRIGHT_BLUE}http://$loopback_ip ${WHITE}";
    echo "$eth_iface    Interface Connection (Private) : ${BRIGHT_BLUE}http://$eth_ip ${WHITE}";
    br;
  else
    c && br;
    echo "${BOLD}Apache Server Off [${RED}x${WHITE}]"
    br
  fi
}

# this alias to start the apache2 service
alias apon="allow_sudo && apon"

# this function for apch alias
function apon(){
  cd /var/www/html;
  sudo systemctl start apache2;
  stap;
}

# this alias to stop the apache2 service
alias apoff="allow_sudo && apoff"

# this function for apch alias
function apoff(){
  sudo systemctl stop apache2;
  stap;
}

# this alias to open the
# Apache2 server directory
alias apd="apd"

# this function for apd alias
function apd(){
  op /var/www/html
}

# # this function to view the current mongodb
# # service, its status
# function mgst(){
#   if [[ $(pgrep mongod) ]]; then
#     c && br && echo " MongoDb Server is Active" && br;
#
#     local eth_ip=$(ifconfig eth0 | grep "inet " | awk '{print $2}');
#
#     if [ -d /sys/class/net/wlan0 ]; then
#       local wlan_ip=$(ifconfig wlan0 | grep "inet " | awk '{print $2}');
#       echo " eth0  Interface Connection : http://$eth_ip";
#       echo " wlan0 Interface Connection : http://$wlan_ip";
#       br;
#     else
#       echo " $eth_ip" && br;
#     fi
#   else
#     c && br && echo " MongoDb Server is Off" && br;
#   fi
# }

# # this alias to start the mongod service
# alias mongon="mongon"
#
# # this function for mongon alias
# function mongon(){
#   allow_sudo;
#   sudo systemctl start mongod;
#   mgst;
# }
#
# # this alias to stop the mongod service
# alias mongoff="mongoff"
#
# # this function for mongoff alias
# function mongoff(){
#   allow_sudo;
#   sudo systemctl stop mongod;
#   mgst;
# }

# here to view the ssh status
alias sth="sth"

# this function for sth alias
function sth(){
  c && br;
  if [[ $(pgrep sshd) ]]; then
    c && br;
    echo "${BOLD}Ssh Server Active [${GREEN}✓${WHITE}]"
    br;
    if [ -d /sys/class/net/wlan0 ]; then
      local wifi_iface="wlan0"
      local wifi_ip=$(ifconfig $wifi_iface | grep "inet " | awk '{print $2}');
      echo "Ssh Connection via $wifi_iface Interface : ${BLUE}ssh $USER@$wifi_ip${WHITE}";
    fi

    local eth_iface="eth0"
    local eth_ip=$(ifconfig $eth_iface | grep "inet " | awk '{print $2}');
    echo "Ssh Connection via $eth_iface Interface : ${BLUE}ssh $USER@$eth_ip${WHITE}";
  else
    echo "${BOLD}Ssh Server Off [${RED}x${WHITE}]"
  fi
  br
}

# this alias to enable the ssh server
alias sshon="sshon"

# this function for sshon alias
function sshon(){
  svc_on ssh;
  sth;
}

# this alias to kill the ssh server process
alias sshoff="allow_sudo && sshoff"

# this function for sshoff alias
function sshoff(){
  # sudo kill $(sudo lsof -t -i:22);
  # or use this in termux
  if [[ $(pgrep sshd) ]]; then
    sudo kill $(pgrep sshd)
  fi
  sth;
}

# this function to check if pfsense is reachable
# coded 01/29/2024
function reaching_check(){
  # c && br;

  local pfsense_IP="192.168.19.11"
  local check_message="Checking PfSense Server..."
  local check_IP="ping -c 1 -W 5 "
  local reachable="echo ' $check_message' && eval $check_IP $pfsense_IP &> /dev/null;"
  # the -c 1 means we send one packet to test it
  # the -W 5 means if the ping have 5 seconds to check
  # as always we run it in background in order to
  # not see all the boring logs messages

  if eval $reachable ;then
    # if PfSense is reachable then
    # we execute the next command after
    # this function calling
    eval "$@"
  else;
    echo " PfSense Server is not running."
  fi
}

# this alias to view the pfsense state
alias pfst="pfst"

# this function for pfst alias
function pfst(){
  c && br;
  function status(){
    # Check if we found a process having
    # the same PID as the PfSense's
    # Therefore the server is running
    if ps | grep $PFSENSE_PID; then
      c && br;
      echo " PfSense Connection is Established";
      echo " PfSense PID : $PFSENSE_PID"
    else
      # Otherwise the PfSense Server
      # has been closed or
      # is not reachable
      c && br;
      echo " PfSense Connection is Closed";
    fi
  }

  # Always checking if the IP
  # is reachable before viewing
  # the PfSense server status
  reaching_check status
}

# This function to connect to
# the PfSense Server
function pfsense_connect(){
  # PfSense Static IP adress
  local pfsense_IP="192.168.19.11";
  # The browser when we open PfSense GUI
  local browser="google-chrome";

  # here to stop eth0 (bridged adapter)
  # since eth0 is prioritized
  # over eth1 which is the LAN of pfsense
  downnet eth0;

  # here to launch the pfsense GUI
  # as a background process so
  # the terminal won't be filled with logs
  $browser $pfsense_IP &> /dev/null &;
  # xdg-open http://$pfsense_IP

  # here to store the pfsense PID
  # used to kill its process after
  PFSENSE_PID="$!"
}

# this alias to start the pfsense GUI
# 01/29/2024
alias pfson="allow_sudo && pfson"

# this function for pfsense alias
function pfson(){
  reaching_check pfsense_connect;
  pfst;
}

# this alias to close the pfsense GUI
# 01/29/2024
alias pfsoff="allow_sudo && pfsoff"

# this function for pfsoff alias
function pfsoff(){
  sudo kill $PFSENSE_PID;
  # here to restart eth0 (bridged adapter)
  # since eth0 is down when pfsense ran
  upnet eth0;

  # Feedback message
  # Calling it twice because at
  # first instance the status
  # is not well refreshed
  clear && pfst;
  clear && pfst;
}

# this alias to start systemctl based services
alias svc_on="allow_sudo && svc_on"

# this function for svc_on alias
function svc_on(){
  sudo systemctl start "$1";
}

# this alias to stop systemctl based services
alias svc_off="allow_sudo && svc_off"

# this function for svc_off alias
function svc_off(){
  sudo systemctl stop "$1";
}

# this alias to view systemctl
# based services status
alias svc_stat="allow_sudo && svc_stat"

# this function for svc_stat alias
function svc_stat(){
  sudo systemctl status "$1";
}

# this alias to show if a service if on or off
alias svc_show_stat="allow_sudo && svc_show_stat"

# this function for svc_show_stat alias
function svc_show_stat(){
  br;

  local service_name="$1";
  local check_command="$2";

  if [[ "$check_command" == *"Active: active"* ]]; then
    echo "${BOLD}$service_name Active [${GREEN}✓${WHITE}]";
  elif [[ "$check_command" =~ ^[0-9]+$ ]]; then
    echo "${BOLD}$service_name Active [${GREEN}✓${WHITE}]";
  else
    echo "${BOLD}$service_name Off [${RED}x${WHITE}]";
  fi

  br;
}

# this alias to start the sql service
alias sqlon="sqlon"

# this function for sqlon alias
function sqlon(){
  svc_on mysql;
  sqls;
}

# this alias to stop the sql service
alias sqloff="sqloff"

# this function for sqloff alias
function sqloff(){
  svc_off mysql;
  sqls;
}

# this alias to view the sql service
alias sqls="sqls"

# this function for sqloff alias
function sqls(){
  local name="MySQL Server"
  local cmd="$(pgrep mariadb)"
  
  if [[ -z "$cmd" ]]; then
    svc_show_stat "$name" "Active: inactive";
  else
    svc_show_stat "$name" "Active: active";
  fi
}

# this alias to check sendmail process
alias mails="mails"

# this function for mails alias
function mails(){
  local name="Mail Server"
  local cmd="$(sudo systemctl status postfix)"
  svc_show_stat "$name" "$cmd"
}

# this alias to start sendmail service
alias mailon="mailon"

# this function for mailon alias
function mailon(){
  svc_on postfix;
  mails;
}

# this alias to stop sendmail service
alias mailoff="mailoff"

# this function for mailon alias
function mailoff(){
  svc_off postfix;
  mails;
}

# this alias to check snmp service
alias snmps="snmps"

# this function for snmps alias
function snmps(){
  local name="SNMP Server";
  local cmd="$(pgrep snmpd)";
  svc_show_stat $name $cmd;
}

# this function to start snmpd service
alias snmpon="snmpon"

# this function for snmpon alias
function snmpon(){
  svc_on snmpd;
  snmps;
}

# this alias to stop the snmp service
alias snmpoff="snmpoff"

# this function for snmpoff alias
function snmpoff(){
  svc_off snmpd;
  snmps;
}

# this alias to start the postgresql service
alias psqlon="allow_sudo && psqlon"

# this function for sqlon alias
function psqlon(){
  sudo service postgresql start;
  psqls;
}

# this alias to stop the postgresql service
alias psqloff="allow_sudo && psqloff"

# this function for sqloff alias
function psqloff(){
  sudo service postgresql stop;
  psqls;
}

# this alias to view the postgresql service
alias psqls="psqls"

# this function for psqls alias
function psqls(){
  local name="PostgreSQL Server"
  local cmd="$(sudo service postgresql status)"
  svc_show_stat $name $cmd;
}

# this alias to call the sqlite3.Exe file
alias sqlite="sqlite"

# this function for ssqlite alias
function sqlite(){
  if [[ $# -eq 0 ]]; then
    echo "■■▶ Please specify a file.db  ";  
  else
    if [[ $# -eq 1 && "${1##*.}" -eq "db" ]]; then
      c && br;
      sqlite3 $@;
      cv;
    else
      sqlite3 $@;
    fi
  fi
}

# this alias to start the sql cli
alias rdb="allow_sudo && rdb"

# this function for rdb alias
function rdb(){
  if ! pgrep mysql > /dev/null; then
    sudo service mariadb start &>/dev/null
  fi
  c && br
  local user=${1:-root}
  echo "${BOLD}MySQL Server Active [${GREEN}✓${WHITE}]"
  echo "${BOLD}User : $user"
  local is_root='[[ "$user" == "root" ]]';
  local flag=$(eval "$is_root" && echo "" || echo "-p");
  sudo mysql -u $user $flag;
  br
  function check_mysql_server(){
    echo -ne "${BOLD}${WHITE}[${GREEN}?${WHITE}]${WHITE} ${GREEN}Stop ${WHITE}MySQL Server ? (y/n) ";
    read server
    if [ "$server" = "y" ]; then
      # echo -ne " ${WHITE}[${GREEN}+${WHITE}]${WHITE} Stopping ${GREEN}MySQL ${WHITE}Server  ";
      echo "${BOLD}${WHITE}[${GREEN}+${WHITE}]${WHITE} Stopping MySQL Server ... "
      sudo service mariadb stop &>/dev/null
      echo "${BOLD}${WHITE}[${GREEN}+${WHITE}]${WHITE} MySQL Server Stopped  ... ${GREEN}✓"
    elif [ "$server" = "n" ];then
      echo "${BOLD}${WHITE}[${GREEN}+${WHITE}]${WHITE} Keeping ${GREEN}MySQL ${WHITE}Server ${GREEN}On";
    else
      check_mysql_server
    fi
  }
  check_mysql_server
}

# this alias to start the sql cli
alias rdbp="rdbp"

# this function for rdbp alias
function rdbp(){
  clear && br 2 && sudo clear;
  sudo systemctl start psql;
  sudo mysql -u root;
  sudo systemctl stop psql;
}

# this alias to view the irc sever status
alias irth="irth"

# this function for irth alias
function irth(){
  c && br 2 && sudo clear;
  echo "    irc server status : ";
  br;
  sudo service inspircd status ;
  br;
}

# this alias to start the irc server
alias ircon="ircon"

# this function for ircon alias
function ircon(){
  clear && br 2 && sudo clear;
  sudo service inspircd start;
  irth;
}

# this alias to restart the irc server
alias ircrst="ircrst"

# this function for ircrst alias
function ircrst(){
  clear && br 2 && sudo clear;
  sudo service inspircd restart;
  irth;
}

# this alias to stop the irc server
alias ircoff="ircoff"

# this function for ircoff alias
function ircoff(){
  clear && br 2 && sudo clear;
  sudo service inspircd stop;
  irth;
}

# this alias to git add and git commit at the same time
alias gad="gad"

# this function for gad alias
function gad(){
  if [[ $# -eq 0 ]]; then
    git add --all && git commit
  elif [[ $# -eq 1 ]]; then
    git add --all && git commit -m "$1"
  elif [[ $# -eq 2 ]]; then
    git add "$1" && git commit "$1" -m "$2";
  fi
}

# this alias to create a new github repository using github cli
alias ghc="ghc"

# this function to sanitize the repository name
function sanitize_repo_name() {
  local repo_name="$1"
  # Replace any characters that are not alphanumeric or hyphen with hyphen
  local sanitized_name="$(echo "$repo_name" | sed -E 's/[^a-zA-Z0-9-]+/_/g')"
  echo "$sanitized_name"
}

#this function for ghc alias
# function ghc() {
#   local repo_name="$(basename $PWD)"
#   local sanitized_repo_name="$(sanitize_repo_name "$repo_name")"
#   gh repo create "$sanitized_repo_name" --public -c
#   if [ $? -eq 0 ]; then
#     mv "$sanitized_repo_name/.git" . && rm -rf "$sanitized_repo_name"
#   fi
# }
function ghc() {
  local repo_name="$(basename $PWD)"
  local sanitized_repo_name="$(sanitize_repo_name "$repo_name")"

  if [[ -n "$sanitized_repo_name" ]]; then
    if [[ $# -eq 1 && "$1" == "private" ]]; then
      gh repo create "$sanitized_repo_name" --private -c;
    else
      gh repo create "$sanitized_repo_name" --public -c;
    fi
    mv "$sanitized_repo_name/.git" . && rm -rf "$sanitized_repo_name";
  fi
}


#this alias to delete a github repo via Github CLI 
alias ghd="ghd"

function ghd(){
  if [[ $# -eq 0 ]]; then
    local repo_name="$(basename $PWD)"
    local sanitized_repo_name="$(sanitize_repo_name "$repo_name")"

    gh repo delete "$sanitized_repo_name" --yes;
    rm -rf .git;
  elif [[ $# -eq 1 ]]; then
    gh repo delete "$1" --yes;
  fi
}

#this alias to view all repos in the GitHub
alias ghls="gh repo list"

#this function to bring a connection interface up 
function upnet(){
  sudo ifconfig "$1" up;
}

# this function to declare default git
# based branch aliases variables
# today 2024-03-09 20:38
# function init_git_variables(){
#   is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)
#   if [[ $is_a_git_repo == "true "]]; then
#     default_branch=$(basename $(git symbolic-ref refs/remotes/origin/HEAD))
#     current_branch=$(git rev-parse --abbrev-ref HEAD)
#   else
#     echo "not in a git repo"
#   fi
# }

#this alias to rename a git branch
alias gnm="gnm"

#this function for gnm alias
function gnm(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    if [[ $# -eq 1 ]]; then
      git branch -M $current_branch "$1";
      cv;
    elif [[ $# -eq 0 ]]; then
      echo "${BOLD} ■■▶ Please pass the new name of '$current_branch' branch as argument " && br;
    else
      echo "${BOLD} ■■▶ Usage : gnm new_name_of_the_branch" && br;
    fi
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to switch to the last git branch
alias gck="gck";

#this function for gck alias
function gck(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    local default_branch=$(basename $(git symbolic-ref refs/remotes/origin/HEAD))
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    if [[ $# -eq 0 ]]; then
      if [[ "$current_branch" != "$default_branch" ]]; then
        git checkout "$default_branch"
      fi
    elif [[ $# -eq 1 ]]; then
      if ! git rev-parse --verify "$1" >/dev/null 2>&1; then
        local new_branch="$1"
        function check_new_branch(){
          echo -ne "${BOLD}${WHITE}New branch${GREEN} "$new_branch"${WHITE} ? (y/n) ${RESET}";
          read branch
          if [ "$branch" = "y" ]; then
            git checkout -b "$new_branch";
          elif [ "$branch" = "n" ];then
            return 1
          else
            check_new_branch
          fi
        }
        check_new_branch
      else
        git checkout "$1";
      fi
    else
      echo "${BOLD} gck        ==> switch to the default branch";
      echo "${BOLD} gck branch ==> swith to the specified branch" && br;
    fi
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to switch to the last git branch
alias gcb="gcb";

#this function for gcb alias
function gcb(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    if [[ $# -eq 0 ]]; then
      git checkout -;
    else
      echo "${BOLD} ■■▶ Usage : gcb (no argument)" && br;
    fi
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to create a new branch and switch to it
alias gbr="gbr"

#this function for gbr alias
function gbr(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    if [[ $# -eq 1 ]]; then
      git checkout -b "$1";
    elif [[ $# -eq 0 ]]; then
      git branch -a;
    else
      echo "${BOLD} ■■▶ Usage : gbr new_branch" && br;
    fi
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to delete a branch
alias gbd="gbd"

#this function for gbd alias
function gbd(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    local default_branch=$(basename $(git symbolic-ref refs/remotes/origin/HEAD))
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    if [[ $# -eq 1 ]]; then
      # check if the branch doesn't exist
      if ! git rev-parse --verify "$1" >/dev/null 2>&1; then
        echo "${BOLD} ■■▶ Fatal ! $1 is a Non Existing branch " && br;
      else
        if [[ "$current_branch" == "$default_branch" ]]; then
          echo "${BOLD} ■■▶ Fatal ! Cannot Delete the Default Branch " && br;
        else
          git checkout $default_branch;
          git branch -D "$1";
        fi
      fi
    elif [[ $# -eq 0 ]]; then
      if [[ "$current_branch" == "$default_branch" ]]; then
        echo "${BOLD} ■■▶ Fatal ! Cannot Delete the Default Branch " && br;
      else
        function check_delete_branch(){
          echo -ne "${BOLD}${WHITE}Delete branch${GREEN} "$current_branch"${WHITE} ? (y/n) ${RESET}";
          read delete_branch
          if [ "$delete_branch" = "y" ]; then
            git checkout "$default_branch";
            git branch -D "$current_branch";
          elif [ "$delete_branch" = "n" ];then
            return 1
          else
            check_delete_branch
          fi
        }
        check_delete_branch
      fi
    else
      br
      echo "${BOLD} gbd        --> Delete the current branch";
      echo "${BOLD} gbd branch --> Delete the specified branch" && br;
    fi
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

# this alias to revert back to last commit
alias grst="git checkout -- ."

# this alias to push changes on current repo to remote repo
alias gpsh="gpsh"

# this function for gpsh alias
function gpsh(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    local current_branch=$(echo $(git branch) | awk -F "*" '{print $2}' | awk -F " " '{print $1}');
    git push origin $current_branch;
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

# this alias to pull changes from remote repo
alias gpl="gpl"

# this function for gpsh alias
function gpl(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    local current_branch=$(echo $(git branch) | awk -F "*" '{print $2}' | awk -F " " '{print $1}');
    git pull origin $current_branch;
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

# this alias to view the git log commits number
alias glc="glc"

# this function for glc alias
function glc(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    local current_branch=$(echo $(git branch) | awk -F "*" '{print $2}' | awk -F " " '{print $1}');
    local commits_num=$(git log --oneline | wc -l);
    local last_commit=$(git log --format="%H" -n 1);
    local last_commit_message=$(git show --format=%B -s "$last_commit" | tr '\n' ' ');
    local last_commit_author=$(git log --format='%an' -n 1)

    echo "${BOLD}${GREEN} $last_commit_author ${WHITE}has ${BRIGHT_BLUE}$commits_num commits";
    echo "${BOLD}${WHITE} Last Commit on ${GREEN}$current_branch ${WHITE}: $last_commit_message";
    br;
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

# this alias to merge branches
alias gmb="gmb"

# this function for gmb alias
function gmb(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    if [[ $# -eq 1 ]]; then
      # check if the branch doesn't exist
      if ! git rev-parse --verify "$1" >/dev/null 2>&1; then
        echo "${BOLD} ■■▶ Fatal ! $1 is a Non Existing branch " && br;
      else
        if [[ "$current_branch" == "$1" ]]; then
          echo "${BOLD} ■■▶ Fatal ! Cannot Merge Identical Branch " && br;
        else
          git merge "$1";
        fi
      fi
    elif [[ $# -eq 0 ]]; then
      echo "${BOLD} ■■▶ Fatal ! Specify the Branch to merge to $current_branch" && br;
    fi
  else
    echo "${BOLD} ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this function to bring a connection interface down 
function downnet(){
  sudo ifconfig "$1" down;
}

#this function to switch from ethernet to wireless connection
function wf(){
  c && br 2;
  sudo clear;
  br 2;
  if [ -d /sys/class/net/wlan0 ]; then
    downnet eth0 && upnet wlan0;
    echo "w i r e l e s s" | figlet -t -c;
    tlk "wifi on";
    br && sleep 1 && cv;
  else
    echo "Can't switch to wireless, wlan0 not found";
    br;
  fi
}

#this function to switch from wireless to ethernet connection
function rj(){
  c && br 2;
  sudo clear;
  br 2;
  if [ -d /sys/class/net/wlan0 ]; then
    downnet wlan0 && upnet eth0;
  else
    upnet eth0;
    br;
  fi
  echo "e t h e r n e t" | figlet -t -c;
  tlk "ethernet on";
  br && sleep 1 && cv;
}

#this alias to connect directly to the Pixel 3XL ssh server
alias cnt="cnt"

#this function for cnt alias
# 2023-10-13
# for now that My PIXEL 3XL is lost, I will change the function
# function cnt(){
#   clear;
#   br;
#   #echo s s h   c o n n e c t i o n' | figlet -t -c;
#   #sleep 0.5;
#   ssh u0_a55@192.168.68.112 -p 8022;
#   cv;
# }

function cnt(){
  c && br;
  sudo clear;
  if [ -d /sys/class/net/wlan0 ]; then
    if sudo ifconfig eth0 &> /dev/null; then
      wf;
    elif sudo ifconfig wlan0 &> /dev/null; then
      rj;
    fi
  else
    echo "Can't switch them, wlan0 not found"
  fi
}

# #this alias to download a file from the Pixel 3XL ssh server
# alias dwld="dwld"
#
# #this function for dwld alias
# function dwld() {
#   local src hst dest
#   src="$1"
#   hst="h471x@192.168.68.112"
#   dest="${2:-$PWD}"
#
#   scp -P 8022 -r "$hst":~/"$src" "$dest"
# }

# #this alias to upload a file from this PC to the Pixel 3XL ssh server
# alias upld="upld"
#
# #this function for dwld alias
# function upld(){
#   if [[ $# -eq 1 ]]; then #if there is only one argument it will upload the file to home directory
#     if [[ -f $1 ]]; then #if the argument is a file
#       scp -P 8022 "$1" u0_a249@192.168.68.112:~
#     else
#       scp -P 8022 -r "$1" u0_a249@192.168.68.112:~
#     fi # upload the file / directory in the second argument
#   elif [[ $# -eq 2 ]]; then
#     if [[ -f $1 ]]; then #if the argument is a file
#       scp -P 8022 "$1" u0_a249@192.168.68.112:~/"$2"
#     else
#       scp -P 8022 -r "$1" u0_a249@192.168.68.112:~/"$2"
#     fi
#   fi
# }


# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

#session_open, variable to check if there is already a terminal session
#session_open=0

kill-line() {
  if [[ $BUFFER == "" ]]; then
    zle backward-kill-line
  else
    zle kill-whole-line
  fi
}

zle -N kill-line
bindkey "²²" kill-line

eval $(thefuck --alias)
