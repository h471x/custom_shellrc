set autocd # change directory just by typing his name
setopt promptsubst # enable command substitution in prompt

# configure keybindings
bindkey -e #emacs keybindings
bindkey ' ' magic-space #do history expansion on space

# This is for fastfile Oh-My-Zsh Plugin
fastfile_var_prefix='$'

# Path to your oh-my-zsh installation.
export ZSH="$HOME/.oh-my-zsh"

# Binaries
WSL_PATH=/home/h471x/.local/bin/
SQLITE_PATH=/mnt/c/Program\ Files/sqlite
QT_PATH=/mnt/d/NTSOA/INSTALLED/QT/Tools/QtCreator/bin
PYTHON_PATH=/mnt/d/NTSOA/INSTALLED/PYTHON
VIRTUAL_BOX_PATH=/mnt/c/Virtual\ Box
BINARY_PATH=$WSL_PATH:$SQLITE_PATH:$QT_PATH:$VIRTUAL_BOX_PATH:$PYTHON_PATH

# Browsers
CHROME_PATH=/mnt/c/Program\ Files/Google/chrome/Application/
EDGE_PATH=/mnt/c/Program\ Files\ (x86)/Microsoft/Edge/Application/
BROWSER_PATH=$CHROME_PATH:$EDGE_PATH

# Applications
NPM_PATH=/mnt/c/Users/lab_l/AppData/Roaming/npm/npm
POT_PLAYER_PATH=/mnt/d/NTSOA/INSTALLED/POT\ PLAYER/PotPlayer
FL_STUDIO_PATH=/mnt/d/NTSOA/INSTALLED/FL\ STUDIO\ 12
APP_PATH=$NPM_PATH:$POT_PLAYER_PATH:$FL_STUDIO_PATH

# Including all the paths
PATH=$BINARY_PATH:$BROWSER_PATH:$APP_PATH:$PATH

# this to make Github CLI know which default browser it would use
# this WSL issue was solved in gh GitHub Repo Pull Request
export BROWSER="chrome.exe"

# Oh-My-Zsh custom theme
ZSH_THEME="powerlevel10k/powerlevel10k"

# Declare the variable for zsh-syntax-highlighting styles
typeset -A ZSH_HIGHLIGHT_STYLES

# I found those from ~/.oh-my-zsh/plugins/zsh-syntax-highlighting/highlighters/main/README.md
# ZSH_HIGHLIGHT_STYLES[path]='fg=#3B78FF,bold'
ZSH_HIGHLIGHT_STYLES[path]='none'
ZSH_HIGHLIGHT_STYLES[autodirectory]=fg='#ffffff'
ZSH_HIGHLIGHT_STYLES[suffix-alias]=fg='none'
ZSH_HIGHLIGHT_STYLES[precommand]=fg='none'
ZSH_HIGHLIGHT_STYLES[arg0]=fg='none'
ZSH_HIGHLIGHT_STYLES[single-quoted-argument]=fg='#23ff45'
ZSH_HIGHLIGHT_STYLES[double-quoted-argument]=fg='#23ff45'
ZSH_HIGHLIGHT_STYLES[single-hyphen-option]='fg=#37b0ff,bold'
ZSH_HIGHLIGHT_STYLES[double-hyphen-option]='fg=#37b0ff,bold'
ZSH_HIGHLIGHT_STYLES[redirection]='fg=#ffe541,bold'
ZSH_HIGHLIGHT_STYLES[globbing]='fg=#ff9000,bold'
ZSH_HIGHLIGHT_STYLES[command-substitution-unquoted]='fg=#d30ccf,bold'
ZSH_HIGHLIGHT_STYLES[command-substitution-delimiter]='fg=#d30ccf,bold'

# ANSI CODES ARIABLES
# Text
RESET="$(printf '\033[0m')"
BOLD="$(printf '\033[1m')"
RED="$(printf '\033[31m')"
GREEN="$(printf '\033[32m')"
ORANGE="$(printf '\033[33m')"
YELLOW="$(printf '\033[33m')"
BLUE="$(printf '\033[34m')"
MAGENTA="$(printf '\033[35m')"
CYAN="$(printf '\033[36m')"
#WHITE="$(printf '\033[37m')"
WHITE="$(printf '\e[97m')"
BLACK="$(printf '\033[30m')"
NC="$(printf '\033[0m')" #Reset colour
#Background
REDBG="$(printf '\033[41m')"
GREENBG="$(printf '\033[42m')"
ORANGEBG="$(printf '\033[43m')"
BLUEBG="$(printf '\033[44m')"
MAGENTABG="$(printf '\033[45m')"
CYANBG="$(printf '\033[46m')"
WHITEBG="$(printf '\033[47m')"
BLACKBG="$(printf '\033[40m')"
RESETBG="$(printf '\e[0m\n')" #Reset background

# Character
CHECKMARK="$(printf '\xE2\x9C\x94')"
QUESTION_MARK="$(printf '\xE2\x9D\x93')"

#Here to launch tmux as default
#case $TERM in
#        screen|tmux-256color);;
#        *)tmux att -t 0 2>/dev/null|| tmux;;
#esac;

# Uncomment the following line to use case-sensitive completion.
CASE_SENSITIVE="true"

# Which plugins would you like to load?
# Standard plugins can be found in $ZSH/plugins/
# Custom plugins may be added to $ZSH_CUSTOM/plugins/
# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(fastfile copyfile vscode extract docker zsh-autosuggestions git nmap terraform sudo themes encode64 python zsh-syntax-highlighting)

# here the color of the auto-suggestion
# ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE=fg=#0000ff"
DISABLE_AUTO_UPDATE="true" #here to disable oh-my-zsh auto update  
source $ZSH/oh-my-zsh.sh

# this alias to clear
alias c="clear"

# this alias to clear but with extra lines
alias x="clear && echo -e && echo -e && echo -e && echo -e && echo -e && echo -e"

# this alias to break a line
alias br="br"

# this function for br alias
function br(){
  if [[ $# -eq 1 ]]; then
    for ((i=1; i<=$1;i++)); do
      echo -e;
    done
  elif [[ $# -eq 0 ]]; then
    echo -e;
  fi
}

# this alias to show the welcome message
alias cvi="cvii"

# here to write a welcome message
function cvii(){
  clear && br 2;
  echo "H    4    7    1    X" | figlet -t -c;
  br 2;
}

x;
# sleep 0.5 && cvi;


# this alias to exit
alias q='exit'

# this alias to give full permission
alias all="all"

# this function for all alias
function all(){
  if [[ $# -eq 0 ]]; then
    if [[ -d "$1" ]]; then
      chmod 700 * && cv;
    elif [[ -f "$1" ]]; then
      chmod 777 * && cv;
    fi
  else
    if [[ -d "$1" ]]; then
      chmod 700 "$@" && cv;
    elif [[ -f "$1" ]]; then
      chmod 777 "$@" && cv;
    fi
  fi
}

# this alias to save a file content to another file
alias sv="sv"

# this function for sv alias
function sv(){
  cat "$1" > "$2";
}

# this alias to reload the zshrc file
alias rld="rld"

# this function for rld alias
function rld(){
  clear;
  source ~/.zshrc;
  sv ~/.zshrc ~/NTSOA/zsh_config/wsl_config/"zshrc[h471X].txt";
  all ~/NTSOA/zsh_config/wsl_config/"zshrc[h471X].txt";
  c && br;
  local saved_message="z s h    s a v e d"
  echo "$saved_message" | figlet -t -c;
  br && sleep 0.5;
  op ~/NTSOA/zsh_config
}

# this alias to edit a file
alias ed="ed"

# this function for ed alias
function ed(){
  # nvim -c "startinsert" "$1" && cv;
  nvim "$1" && cv;
}

# this alias to open the current directory inside neovim
alias nvm="nvm"

# this function for nvm aliases
function nvm(){
  nvim "${1:-.}";
  cv;
  # if we have one argument then nvim will be launched with it,
  # otherwise open the current directory if there is no argument
}

# this alias to open the current directory in windows explorer
alias exop="exop"

# this function for exop alias
function exop(){
  if [[ $# -eq 0 ]]; then
    explorer.exe .;
  elif [[ $# -eq 1 ]]; then
    cd $1;
    explorer.exe .;
  fi
  cv;
}

# this function to open file with browser
function bwsop(){
  local file="$1"
  local formatted_path=$(wslpath -m . | sed -e 's/ /%20/g' -e 's/\\//g')
  local formatted_file=$(echo "$file" | sed -e 's/ /%20/g' -e 's/\\//g')
  case "${1##*.}" in
    html)
      browser="chrome.exe"
      ;;
    pdf)
      browser="msedge.exe"
      ;;
    *)
      browser="chrome.exe"
      ;;
  esac
  $browser "file:///$formatted_path/$formatted_file"
  # nd
  cv
}

# this function to open video file
function play_video(){
  # local video="$1"
  # local formatted_video=$(echo "$file" | sed -e 's/ /%20/g' -e 's/\\//g')
  PotPlayerMini64.exe "$1"
}

# this alias to edit bashrc
alias ct="nvim ~/.zshrc && cv"

# this alias to have the current view
# of working directory content using ls
alias cv="cv"

# this function for cv alias
# updated today 01/25/2024 to adjust the title
# when we have more than 50 visible items
function cv() {
  local folder_content="${target:-$PWD}"
  local target="$1"
  local folder_name=$(basename $folder_content)
  local visible_item=$(ls $folder_content | wc -l)
  local total_item=$(ls -a $folder_content | wc -l)
  local hidden_item=$((total_item - visible_item - 2))

  # this function for the header of cv alias
  function show_header(){
    local folder_header
    if [[ $hidden_item -eq 0 ]]; then
      folder_header="total($visible_item)";
    else
      folder_header="visible($visible_item) hidden($hidden_item) total($(($total_item - 2))) ";
    fi
    echo " ■■▶ $folder_name folder content : $folder_header";
  }

  # this function to show the content of the cv
  function show_content(){
    # local flag="${1:-}"
    # ls $flag $folder_content;
    ls $folder_content
  }

  # this function to show the all of the cv content
  function show_all(){
    c && br;

    if [[ $visible_item -lt 30 ]]; then
      show_header;
      br;
      show_content;
      br;
    else
      show_content;
      br 2;
      show_header;
      br;
    fi
  }
  show_all;
}

# this alias to view the current directory content
alias cvf="cvf"

# this function for cvf alias
# updated today 01/25/2024 to adjust the title
# when we have more than 50 visible items
function cvf() {
  local folder_content="${target:-$PWD}"
  local target="$1"
  local folder_name=$(basename $folder_content)
  local visible_item=$(ls $folder_content | wc -l)
  local total_item=$(ls -a $folder_content | wc -l)
  local hidden_item=$((total_item - visible_item - 2))

  # this function for the header of cv alias
  function show_header(){
    local folder_header
    if [[ $hidden_item -eq 0 ]]; then
      folder_header="total($visible_item)";
    else
      folder_header="visible($visible_item) hidden($hidden_item) total($(($total_item - 2))) ";
    fi
    echo " ■■▶ $folder_name folder content : $folder_header";
  }

  # this function to show the content of the cv
  function show_content(){
    ls -a $folder_content;
  }

  # this function to show the cv
  function show_all(){
    c && br;

    if [[ $hidden_item -lt 30 ]]; then
      show_header;
      br;
      show_content;
      br;
    else
      show_content;
      br 2;
      show_header;
      br;
    fi
  }
  show_all;
}


# this line to count line and words inside a file
alias flc="flc"

# this function for the cl alias
function flc(){
  if [[ -f "$1" ]]; then
    if [ -z "$1" ]; then
      echo "Please provide a filename"
    elif [ -z "$2" ]; then
      c && br;
      echo -ne " ==> "
      file "$1";
      echo -ne " ==> ";
      wc -l "$1" | awk '{print $1, "lines"}';
      echo -ne " ==> ";
      wc -w "$1" | awk '{print $1, "words"}';
      br;
    else
      grep -c "$1" "$2" | awk -v var="$1" '{print $1, var, "in it"}'
    fi
  elif [[ -d "$1" ]]; then
    dc "$1";
  fi
}

# call the cv alias whenever a wrong command is typed
# which doesn't surely exist
command_not_found_handler() {
  local command=$1
  local command_found=0

  # Check if the command is found in the .zshrc file
  if grep -q -E "^alias $command=" "$HOME/.zshrc" ; then
    command_found=1
  fi

  if [[ $command_found -eq 0 ]]; then
    # c && br;
    # echo "n o t     f o u n d " | figlet -t -c | lolcat;
    # br && sleep 0.5 && cv;
    # cv
    echo "${BOLD}${WHITE}[${RED}x${WHITE}]${WHITE} Did you mean ... "
    fuck
  fi
}

# this alias to view the current directory content
# with specifications
alias cvg="cvg"

# this function for cv alias
function cvg(){
  c && br;
  echo "   $(basename "$PWD") folder content with "$1" : ";
  br && ls | grep "$1" && br;
}

# this alias to open a directory
alias op="op"

# this function for op alias
function op(){
  if [[ -d "$1" ]]; then
    if [[ $# -eq 1 ]]; then
      cd "$1" && cv;
    elif [[ $# -eq 2 ]]; then
      cd "$1" && cvg "$2";
    fi
  elif [[ -f "$1" ]]; then
    vf "$1"
  fi
}

# this alias to open the download folder
alias dwl="dwl"

# this function for dwl alias
function dwl(){
  local download_folder_path=/mnt/c/Users/lab_l/Downloads
  op $download_folder_path
}

# this alias to open the desktop
alias dtp="dtp"

# this function for dtp alias
function dtp(){
  local desktop_folder_path=/mnt/c/Users/lab_l/OneDrive/Bureau
  op $desktop_folder_path
}

# this alias to view the books
alias books='exop /mnt/d/NTSOA/"0 ENI"/"ENI 2023"/"ENI L1 LESSONS"/BOOKS'

# this alias to create a directory
alias dr="dr"

# this function for dr alias
function dr(){
  mkdir "$@" && cv;
}

# this alias to remove a directory
alias rd="rd"

# this function for rd alias
function rd(){
  rm -r "$@" && cv;
}

# this alias to open a directory
# and make it as destination
alias opd="opd"

# this function for opd alias
function opd(){
  op "$1" && dt && nd;
}

# this alias to create a directory
# and then directly enter to it
alias opdr="opdr"

# this function for opdr alias
function opdr(){
  dr "$1" && op "$1";
}

# this alias to run an executable file or a script
alias rn="rn"

# this function for rn alias
function rn(){
  #this will look the extension of the file
  # use of ${1%.*} to retrieve the file name
  # explanation :
  # ${file%pattern} ==> this will remove the matched
  # pattern from the file from the end of the file
  #
  # use of ${1##*.} to retrieve extension
  # explanation :
  # ${file##*.} ==> this will remove the longest
  # matched string from the beginning of the file
  # 2024-02-12 00:27
  case "${1##*.}" in
    py)
      all "$1" && c && echo -e && python3 "$1" && echo -e;;
    c || cpp) #update 07/28/2023
      file="$1";
      out="${file%.*}"

      # Condition 1: Check if the file extension is c
      extension='[[ "${file##*.}" == "c" ]]';

      # Condition 2: Check if the file contains math library
      math='grep -E "^#include <math.h>" "$file" >/dev/null';

      # Ternary expressions to determine compiler and flags
      compiler=$(eval "$extension" && echo "gcc" || echo "g++");
      flags=$(eval "$math" && echo "-lm" || echo "");

      # check if an old executable exists
      if [[ -f "$out" ]]; then
        dlf "$out";
      fi

      # Compile the C file
      "$compiler" "$file" -o "$out" $flags;

      # Execute the resulting executable
      all "$out";
      clear && br;
      ./"$out";
      br;;
    js)
      c && br 2 && node "$1" && br
      ;;
    com)
      open_web_app "$1";
      ;;
    bat)
      cmd.exe /c "$1";
      ;;
    html || pdf)
      bwsop "$1"
      ;;
    *)
      all "$1" && c && ./"$1";;
 esac
}


# this alias to update the package
alias upd="upd"

# this function for up alias
function upd(){
  allow_sudo;
  br 2;
  echo "u p d a t i n g .  .  ." | figlet -t -c;
  br && sudo apt update && br;
}

# this alia to update the package
alias upg="upg"

# this function for up alias
function upg(){
  c && echo -e && echo -e && sudo clear && echo -e && echo -e && echo "u p g r a d i n g . . ." | figlet | lolcat && echo -e && sudo apt upgrade && echo -e;
}

# this alias to install package
alias ist="ist"

# this function for ist alias
function ist(){
  case "${1##*.}" in
     git)
      sudo clear && br 2;
      echo "   C l o n i n g .  .  . " | figlet;
      br && echo "Package =======> "${1%.*}" ";
      br && git clone "$1" && br;
      ;;
    *)
      c && br 2;
      sudo clear;
      echo "   I n s t a l l i n g .  .  . " | figlet;
      br && echo "Package =======> "$1" ";
      br && sudo apt install "$1" && br;
      ;;
  esac
}

# this alias to install package
alias rmv="rmv"

# this function for ist alias
function rmv(){
  case "${1##*.}" in
    deb)
      c && echo -e && echo -e && sudo clear && echo -e && echo -e && echo "   r e m o v i n g .  .  . " | figlet | lolcat && echo -e && echo "Package =======> "${1%.*}" " && echo -e && sudo dpkg -r "$1" && echo -e;
      ;;
    *)
      c && echo -e && echo -e && sudo clear && echo -e && echo -e && echo "   r e m o v  i n g .  .  . " | figlet | lolcat && echo -e && echo "Package =======> "$1" " && echo -e && sudo apt remove "$1" && echo -e;
      ;;
  esac
}

# this alias to view inside a file
alias vf="vf"

# this function for vf alias
function vf(){
  #detects if the argument is a file
  if [[ -f "$1" ]]; then
    case "${1##*.}" in
      jpg || png || JPG || PNG || lnk)
        explorer.exe "$1"
        ;;
      html || pdf)
        bwsop "$1"
        ;;
      mp4)
        play_video "$1"
        ;;
      *)
        nvim "$1"
        ;;
    esac
    # cat "$1" | less && cv;
    cv;
  elif [[ -d "$1" ]]; then
    op "$1";
  fi
}

# this alias to rename a file / directory; and display it after
alias nm="nm"

# this function for cpf alias
function nm(){
  mv "$1" "$2" && cv;
}

# this line to count line inside a file
alias cl="linecount"

# this function for the cl alias
function linecount() {
    if [ -z "$1" ]; then
        echo "Please provide a filename"
    elif [ -z "$2" ]; then
        wc -l "$1" | awk '{print $1, "lines"}'
    else
        grep -c "$1" "$2" | awk -v var="$1" '{print $1, var, "in it"}'
    fi
};

# this line to view a command manual
alias mn="mn"

# this function for mn alias
function mn(){
  if [[ $# -eq 1 ]]; then
    man $1 | less
  else
    man $1 | grep $2 | less
  fi
}

# this alias to view tthe manual entry for a command
alias mns="mns"

# this function for mn alias
function mns(){
  if [[ $(command -v "$1") ]]; then
    local manual_path=~/NTSOA/manual
    #here to check if the command exists
    man "$1" | cat > $manual_path/"$1"_manual.txt;
    all $manual_path/"$1"_manual.txt;
    vf $manual_path/"$1"_manual.txt;
    cv;
  else
    cv
    # c && br;
    # echo "n o t     f o u n d " | figlet -t -c | lolcat;
    # br && sleep 0.5 && cv;
  fi
}

# this alias to enter the manual directory
alias mnv="mnv"

# this function for mnv alias
function mnv(){
  if [[ $# -eq 0 ]]; then
    op /home/h471x/NTSOA/manual;
  elif [[ $# -eq 1 ]]; then
    op /home/h471x/NTSOA/manual "$1";
  fi
}

# this alias to go back from a directory
alias b="b"

# this function for b alias
function b(){
  if [[ $# -eq 0 ]]; then
    cd .. && cv
  else
    for ((i=1; i<=$1;i++)); do
      cd .. && cv
    done
  fi
}

# this alias to go to the previous directory
alias nd="nd"

# this function for nd alias
function nd(){
	cd - && cv;
}

# this alias to switch to root
alias ad="ad"

# this function for ad alias
function ad(){
	c && echo -e && echo -e && sudo su && cv;
}

# this alias to simulate the sudo behaviour
alias hndo="hndo"

# this function for hndo alias
function hndo(){
  local attempts=3
  local expected_password="password"

  c && br 2

  while [ $attempts -gt 0 ]; do
    echo -ne "Your Password, Sir : "
    read -s password

    if [ "$password" = "$expected_password" ]; then
      c && br
      eval "$@"
      return
    else
      attempts=$((attempts - 1))
      br
      echo -n "Wrong, Try Again"
      br
      if [ $attempts -gt 0 ]; then
        continue
      else
        echo "hndo: 3 incorrect password attempts"
        return 1
      fi
    fi
  done
}

# this alias to create a file
alias tf="tf"

# this function for tf alias
function tf(){
  touch "$@" && all "$@" && cv;
}

# this alias to delete file
alias dlf="dlf"

# this function for dlf alias
function dlf(){
  rm "$@" && cv;
}

# this line to have destination location for copy / cut
alias dt="dt"

# this function for dst alias
function dt(){
  dest="$PWD" && c && echo -e && echo "d e s t   s a v e d" | figlet -t -c && sleep 0.6 && cv;
}

# this alias to copy a file then display it
alias cpf="cpf"

# this function for cpf alias
function cpf(){
  if [[ $# -eq 2 ]]; then
    if [[ -d "$1" ]]; then #here to check if the first argument is a directory
      cp -r "$1" "$2" && op "$2" && all "$1";
    else
      cp "$1" "$2" && op "$2" && all "$1";
    fi
  elif [[ $# -eq 1 ]]; then
    if [[ -d "$1" ]]; then #here to check if the first argument is a directory
      cp -r "$1" "$dest" && op "$dest" && all "$1";
    else
      cp "$@" "$dest" && op "$dest" && all "$@";
    fi
  fi
}

# this alias to copy the content of a file
alias cnf="cnf"

# this function for cnf alias
function cnf(){
  cat "$1" > "$2" && dlf "$1" && all "$2";
}

# this alias to copy a file then display it
alias mvf="mvf"

# this function for cpf alias
function mvf(){
  if [[ $# -eq 2 ]]; then
    mv "$1" "$2" && op "$2";
  elif [[ $# -eq 1 ]]; then
    mv $@ $dest && op $dest;
    # if there is only one argument,
    # it will move the file / directory
    # to the the variable
    # dest defined in dt alias
  fi
}

# this alias to force delete
alias rdf="rdf"

# this function for rdf alias
function rdf(){
  clear && br 2 && sudo clear;
  sudo rm -rf "$@";
  cv;
}

# this alias to view the pc state
alias pc="c && echo -e && echo -e && neofetch --source ~/.config/neofetch/hn.txt"

#call this pc alias at startup
#pc

# this alias to go to home directory
alias hm="cd && cv"

# this alias to view the windows explorer
alias whm="cd /mnt/c/Users/lab_l/OneDrive/Bureau && op Home.lnk && nd"

#this alias to enter the NTSOA directory
alias hn="op /mnt/d/NTSOA"

#this alias to open the dev folder
alias dev="op /mnt/d/NTSOA/dev/github_repo/"

#this alias to open the notes folder
alias nt="op /mnt/d/NTSOA/dev/0\ NOTES"

# this alias to open the kali linux Vm Shared folder
alias kali="op /mnt/d/NTSOA/INSTALLED/KALI_LINUX"

# this function to convert url to name
function convert_url(){
  url="$1"
  domain="${url%.*}"

  # Capitalize the first letter of the domain
  capitalized_domain="$(tr '[:lower:]' '[:upper:]' <<< ${domain:0:1})${domain:1}"
  echo "$capitalized_domain"
}

# this function to open chrome based app
# it uses the Id of the App we created within
# the Chrome browser, it will take 3 arguments :
# first the name of the App
# then the domain of the App
# and finally the chrome Id
# writen today 2024-02-11 20:13
function open_web_app(){
  # we need sudo permissions
  allow_sudo;

  local browser="chrome.exe"
  local app_domain="$1"
  local app_id="$2"
  local app_name="${3:-$(convert_url $app_domain)}"

  local check="sudo ping -c 1 -W 5 "
  local check_message="Checking $app_name ..."
  local reachable="br && echo ' $check_message' && eval $check $app_domain &> /dev/null;"

  if [ -n "$app_id" ]; then
    open_app="$browser --profile-directory=Default --app-id=$app_id;"
  else
    open_app="$browser $app_domain;"
  fi

  # this function to display the web app status
  function web_app_stat(){
    c && br
    echo "****************************"
    br
    echo " WebApp  : $app_name"
    echo " Link    : $app_domain"
    echo " Browser : $browser"
    echo " Status  : $1"
    br
    echo "****************************"
  }

  # here to call the open_app function
  if eval $reachable; then
    web_app_stat "Connected"
  else
    web_app_stat "Not Connected"
  fi
  eval $open_app
}

# this alias to open chatGpt app
alias gpt="gpt"

# this function for gpt alias
function gpt(){
  local gpt_id="jckaldkomadaenmmgladeopgmfbahfjm"
  local gpt_link="chat.openai.com"
  open_web_app $gpt_link $gpt_id ChatGpt
  # chrome.exe --profile-directory=Default --app-id=$gpt_id
}

# this alias to open Google Gemini app
alias gmn="gmn"

# this function for gmn alias
function gmn(){
  local gmn_id="acehpdabncjaanhpihehcmhidhmbdcoo"
  open_web_app gemini.google.com $gmn_id Gemini
  # chrome.exe --profile-directory=Default --app-id=$gpt_id
}

# this alias to open the GitHub app
alias gthb="gthb"

# this function for gthb alias
function gthb(){
  local github_id="mjoklplbddabcmpepnokjaffbmgbkkgg"
  open_web_app github.com $github_id GitHub
  # chrome.exe --profile-directory=Default --app-id=$github_id
}

# this alias to open Facebook app
alias fb="fb"

# this function for fb alias
function fb(){
  local fb_id="gelmehpcmiomoockkmdlfadoankpigol"
  # if [[ $# -eq 0 ]]; then
    # chrome.exe --profile-directory=Default --app-id=$fb_id
  # elif [[ $1 -eq "-i" ]]; then
    open_web_app facebook.com $fb_id
  # fi
}

# this alias to open Instagram app
alias itg="itg"

# this function for fb alias
function itg(){
  local insta_id="akpamiohjfcnimfljfndmaldlcfphjmp"
  open_web_app instagram.com $insta_id
  # chrome.exe --profile-directory=Default --app-id=$insta_id
}

# this alias to open the discord app
alias dsc="dsc"

# this function for dsc alias
function dsc(){
  local disord_id="magkoliahgffibhgfkmoealggombgknl"
  open_web_app discord.com $disord_id Discord
}

# this alias to recharge the router
alias rtr="rtr"

# this function for rtr alias
function rtr(){
  # chrome.exe "https://www.airtel.mg/broadband/#/user/login" && exit;
  local airtel_id="phkfjlcmjmnindcbhfmnmlikainlhodg"
  open_web_app www.airtel.mg $airtel_id "Airtel Router"
}

# this alias to view the HTX_AP leaderboard
alias htx="htx"

# this function for htx alias
function htx(){
  # chrome.exe "http://192.168.19.1/index.html#" && exit;
  local router_id="kmkglniimomjkiakgepingonppimlibg"
  local router_IP="192.168.19.1"
  open_web_app $router_IP $router_id "h471x Router"
}

# this alias to play directly the typing game
alias typing="cd /mnt/d/NTSOA/dev/github_repo/typing && rn play.sh && cv"

# this alias to show the HTML clock
alias clock="clock"

# this function for clock alias
function clock(){
  cd /mnt/d/NTSOA/Desktop/DIGITAL\ CLOCK
  bwsop clock.html
}

# this alias to access my musics
alias msc="op /mnt/d/NTSOA/music/hiravao"

# this alias to access pictures
alias pct="op /mnt/c/Users/lab_l/OneDrive/Pictures"

# this alias to view the setup
alias setup="op /mnt/d/NTSOA/SETUP"

# this alias to open FL Studio
alias fl="FL64.exe; cv"

# this alias to open VirtualBox
alias vm="VirtualBox.exe"

# this alias to open the state drive
alias sd="op /mnt/d"

# this alias to access directly the eni folder
alias eni="op /mnt/d/NTSOA/0\ ENI/ENI\ 2024/"

# this alias to access the ENI time schedule
alias edt="edt"

# this function for edt alias
function edt(){
  cd /mnt/d/NTSOA/0\ ENI/ENI\ 2024/0\ EDT/L2\ 2024

  # Find the most recent file in the directory
  local recent_file=$(ls -t . | head -n1)

  # Open the most recent time schedule
  explorer.exe $recent_file
  cv
}

#this alias to view the devops folder
alias dvps="op /mnt/d/NTSOA/DEVOPS/devops"

#this alias to view the history
alias hst="hst"

#this function for hst alias
function hst(){
  if [[ $# -eq 0 ]]; then
    history | less && cv
  else
    re='^[0-9]+$'
    #check if the argument is an integrer
    if [[ $1 =~ $re ]]; then
      history | tail -$1 | less && cv
    else  #else if it's a text to grep
      history | grep "$1" | less && cv
    fi
  fi
}

#this alias to specify which command in the history to search
alias hsg="hsg"

#this function for hsg alias
function hsg(){
  if [[ $# -eq 0 ]]; then
    history | less && cv;
  else
    history | grep "$1" | less && cv;
  fi
}

#this alias to show the network configuration
alias ipsh="ipsh"

#this function for ntsh alias
function ipsh(){
  c && br;
  echo "  Available IP Adresses : ";
  br;
  # ifconfig wlan0;
  # br;
  local eth_ip=$(ifconfig eth0 | grep "inet " | awk '{print $2}');
  local wifi_ip=$(ifconfig wifi0 | grep "inet " | awk '{print $2}');

  # if [ -d /sys/class/net/wlan0 ]; then
  #   local wlan_ip=$(ifconfig wlan0 | grep "inet " | awk '{print $2}');
  #   echo " wlan0 ==> $wlan_ip";
  #   echo " eth0  ==> $eth_ip" && br;
  # else
    echo " eth0  ==> $eth_ip" && br;
    echo " wifi0  ==> $wifi_ip" && br;
  # fi
}

# I don't know why but this alias
# make the PC slow down
# # this alias to view saved wifi password
# alias wpass="wpass"
#
# # this function for wpass alias
# function wpass(){
#   cmd.exe /c 'netsh wlan show profiles "ENI 1" key=clear' | grep "Key Content" | awk '{print $4}'
# }

#this alias to view the ssh server status
alias sth="sth"

#this function for sth alias
function sth(){
  # c && br;
  # sudo clear;
  # br;
  # sudo /etc/init.d/ssh status;
  # br;
  if [[ $(pgrep sshd) ]]; then
    br && echo " ssh server is active" && br;
    local ip=$(ifconfig wifi0 | grep inet | awk '{print $2}');
    echo " Connect Via  ==>  ssh $USER@$ip";
  else
    echo " ssh server is off";
  fi
}

#this alias to enable the ssh server
alias sshon="sshon"

#this function for sshon alias
function sshon(){
  clear && br 2;
  sudo clear && br;
  sudo /etc/init.d/ssh start;
  sth;
}

#this alias to kill the ssh server process
alias sshoff="sshoff"

#this function for sshoff alias
function sshoff(){
  clear && br 2;
  sudo clear && br;
  # sudo /etc/init.d/ssh stop;
  if [[ $(pgrep sshd) ]]; then
    sudo kill $(pgrep sshd);
  fi
  sth;
}

#this alias to give sudo
#access before command execution
alias allow_sudo="allow_sudo"

#this function for allow_sudo alias
function allow_sudo(){
  #A simple trick is just to clear
  #the screen, clever ain't it ?
  c && br 2;
  sudo clear
}

#this function to check if pfsense is reachable
# coded 01/29/2024
function reach(){
  c && br;
  allow_sudo;

  local target_IP="$1"
  local check_message="Checking $target_IP reachability..."
  local check_IP="sudo ping -c 1 -W 5 "
  local reachable="br && echo ' $check_message' && eval $check_IP $target_IP &> /dev/null;"
  # the -c 1 means we send one packet to test it
  # the -W 5 means if the ping have 5 seconds to check
  # as always we run it in background in order to
  # not see all the boring logs messages

  if eval $reachable ;then
    #if PfSense is reachable then
    #we execute the next command after
    #this function calling
    # eval "$@"
    echo " $target_IP is reachable"
  else;
    echo " $target_IP is not reachable"
  fi
}

#this variable will store the pixel ssh server IP adress
#local pxl_ip = 192.168.68.112"

#this alias to connect to the Pixel 3XL ssh server
# alias cnt="ssh -p 8022 u0_a249@192.168.68.112 && cv"
#
# #this alias to download a file from the Pixel 3XL ssh server
# alias dwld="dwld"
#
# #this function for dwld alias
# function dwld(){
#   if [[ -f $1 ]]; then #if the argument is a file
#     scp -P 8022 u0_a249@192.168.68.112:~/"$1" $PWD
#   else
#     scp -P 8022 -r u0_a249@192.168.68.112:~/"$1" $PWD
#   fi
# }
#
# #this alias to upload a file from this PC to the Pixel 3XL ssh server
# alias upld="upld"
#
# #this function for dwld alias
# function upld(){
#   if [[ $# -eq 1 ]]; then #if there is only one argument it will upload the file to home directory
#     if [[ -f $1 ]]; then #if the argument is a file
#       scp -P 8022 "$1" u0_a249@192.168.68.112:~
#     else
#       scp -P 8022 -r "$1" u0_a249@192.168.68.112:~
#     fi # upload the file / directory in the second argument
#   elif [[ $# -eq 2 ]]; then
#     if [[ -f $1 ]]; then #if the argument is a file
#       scp -P 8022 "$1" u0_a249@192.168.68.112:~/"$2"
#     else
#       scp -P 8022 -r "$1" u0_a249@192.168.68.112:~/"$2"
#     fi
#   fi
# }

#this function to sanitize the repository name
function sanitize_repo_name() {
  local repo_name="$1"
  # Replace any characters that are not alphanumeric or hyphen with hyphen
  local sanitized_name="$(echo "$repo_name" | sed -E 's/[^a-zA-Z0-9-]+/_/g')"
  echo "$sanitized_name"
}

#this alias to create a new github repository using github cli 
alias ghc="ghc"

# function ghc() {
#   local repo_name="$(basename $PWD)"
#   local sanitized_repo_name="$(sanitize_repo_name "$repo_name")"
#
#   if [[ $? -eq 0 ]]; then
#     gh repo create "$sanitized_repo_name" --public -c;
#     mv "$sanitized_repo_name/.git" . && rm -rf "$sanitized_repo_name";
#   elif [[ $# -eq 1 ]]; then
#     if [[ "$1" == "private" ]]; then
#       gh repo create "$sanitized_repo_name" --private -c;
#       mv "$sanitized_repo_name/.git" . && rm -rf "$sanitized_repo_name";
#     else
#       gh repo create "$1" --public -c;
#     fi
#     # mv "$1"/.git . && rm -rf "$1";
#     # echo "$1" > .name;
#     # echo .gitignore > .gitignore;
#     # echo .name >> .gitignore;
#   fi
# }

function ghc() {
  local repo_name="$(basename $PWD)"
  local sanitized_repo_name="$(sanitize_repo_name "$repo_name")"

  if [[ -n "$sanitized_repo_name" ]]; then
    if [[ $# -eq 1 && "$1" == "private" ]]; then
      gh repo create "$sanitized_repo_name" --private -c;
    else
      gh repo create "$sanitized_repo_name" --public -c;
    fi
    mv "$sanitized_repo_name/.git" . && rm -rf "$sanitized_repo_name";
  fi
}


#this alias to delete a github repo via Github CLI
alias ghd="ghd"

#this function for ghd alias 
function ghd(){
  if [[ $# -eq 0 ]]; then
    local repo_name="$(basename $PWD)"
    local sanitized_repo_name="$(sanitize_repo_name "$repo_name")"

    if [[ -f ./.name ]]; then
      gh repo delete $(cat ./.name) --yes;
      rm -rf .name .gitignore;
    else
      gh repo delete "$sanitized_repo_name" --yes;
    fi
    rm -rf .git;
  elif [[ $# -eq 1 ]]; then
    gh repo delete "$1" --yes;
  fi
}

#this alias to git add and git commit at the same 00:31
alias gad="gad"

#this function for gad alias
function gad(){
  git add "$1" && git commit "$1" -m "$2";
}

#this alias to view all repos in the GitHub
alias ghls="gh repo list"

#this alias to rename a git branch
alias gnm="gnm"

#this function for gnm alias
function gnm(){
  if [[ -d ./.git ]]; then
    local current_branch=$(echo $(git branch) | awk -F "*" '{print $2}' | awk -F " " '{print $1}');

    if [[ $# -eq 1 ]]; then
      git branch -M $current_branch "$1";
      cv;
    elif [[ $# -eq 0 ]]; then
      echo " ■■▶ Please pass the new name of '$current_branch' branch as argument " && br;
    else
      echo " ■■▶ Usage : gnm new_name_of_the_branch" && br;
    fi
  else
    echo " ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to switch to the last git branch
alias gck="gck";

#this function for gck alias
function gck(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    if [[ $# -eq 0 ]]; then
      # local default_branch=$(grep default ~/.gitconfig | awk '{print $3}');
      # git checkout $default_branch;
      # nice but I can't loop over branches
      # so I update the code today 02/04/2024
      local default_branch=$(git config --get init.defaultBranch)
      # local current_branch=$(git rev-parse --abbrev-ref HEAD)

      # if [[ "$current_branch" != "$default_branch" ]]; then
        git checkout "$default_branch"
      # else
      #   local branches=($(git for-each-ref --format='%(refname:short)' refs/heads/))
      #   local current_index=0
      #
      #   for ((i=0; i<${#branches[@]}; i++)); do
      #     if [[ "${branches[$i]}" == "$current_branch" ]]; then
      #       current_index=$i
      #       break
      #     fi
      #   done
      #
      #   current_index=$(( (current_index + 1) % ${#branches[@]} ))
      #   git checkout "${branches[$current_index]}"
      # fi
    elif [[ $# -eq 1 ]]; then
      git checkout "$1";
    else
      echo " ■■▶ Usage : gck branch_to_switch" && br;
    fi
  else
    echo " ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to switch to the last git branch
alias gcb="gcb";

#this function for gcb alias
function gcb(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    if [[ $# -eq 0 ]]; then
      git checkout -;
    else
      echo " ■■▶ Usage : gcb (no argument)" && br;
    fi
  else
    echo " ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to create a new branch and switch to it
alias gbr="gbr"

#this function for gbr alias
function gbr(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    if [[ $# -eq 1 ]]; then
      git checkout -b "$1";
    elif [[ $# -eq 0 ]]; then
      # echo " ■■▶ Please pass the name of the new branch as argument " && br;
      git branch -a;
    else
      echo " ■■▶ Usage : gbr new_branch" && br;
    fi
  else
    echo " ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to delete a branch
alias gbd="gbd"

#this function for gbd alias
function gbd(){
  local is_a_git_repo=$(git rev-parse --is-inside-work-tree 2>/dev/null)

  if [[ "$is_a_git_repo" == "true" ]]; then
    if [[ $# -eq 1 ]]; then
      # local default_branch=$(grep default ~/.gitconfig | awk '{print $3}');
      local default_branch=$(git config --get init.defaultBranch)
      local current_branch=$(git rev-parse --abbrev-ref HEAD)
      # if [[ "$1" != "$default_branch" ]]; then
        # gck;
      # fi
      if [[ "$current_branch" != "$default_branch" ]]; then
        git checkout $default_branch;
      fi
      git branch -D "$1";
    elif [[ $# -eq 0 ]]; then
      echo " ■■▶ Please pass the name of the branch to delete as argument " && br;
    else
      echo " ■■▶ Usage : gbd branch_to_delete" && br;
    fi
  else
    echo " ■■▶ This won't work, you are not in a git repo !" && br;
  fi
}

#this alias to switch to windows terminal
alias wds="wds"

#this function for wds alias
function wds(){
  c && br 2;
  cmd.exe;
  cv;
}

#this alias to switch to powershell terminal
alias pws="pws"

#this function for pws alias
function pws(){
  c && br 2;
  powershell.exe;
  cv;
}

#this alias to enter cmd as admin
alias cmd="cmd"

#this function for cmd alias
function cmd(){
  powershell.exe -command "Start-Process cmd -Verb RunAs";
  x;
}

# this alias to open ThemeTool
alias thm="thm"

# this function for thm alias
function thm(){
  powershell.exe -command "Start-Process D:\NTSOA\INSTALLED\THEME_TOOL\ThemeTool.exe -Verb RunAs"
}

#this alias to call the sqlite3.Exe file
alias sqlite="sqlite"

#this function for ssqlite alias
function sqlite(){
  if [[ $# -eq 0 ]]; then
    echo "■■▶ Please specify a file.db  ";  
  else
    if [[ $# -eq 1 && "${1##*.}" -eq "db" ]]; then
      c && br;
      sqlite3.exe $@;
      cv;
    else
      sqlite3.exe $@;
    fi
  fi
}

# this alias to launch windows python
alias py="python.exe"

# # this alias to locate python modules
# alias pyfn="pyfn"
#
# # this function for pyfn alias
# function pyfn() {
#   c && br
#   local python_module="$1"
#   local module_location
#   module_location=$(pip show "$python_module" | awk '/Location:/{print $2; exit}')
#   if [ -n "$module_location" ]; then
#     local module_status="Found"
#     cd "$module_location/$python_module" || return 1
#   else
#     c && br
#     local module_status="Not Found"
#   fi
#   echo "*********************"
#   br
#   echo " Module : $python_module"
#   echo " Status : $module_status"
#   br
#   echo "*********************"
# }


# this alias to run npm
alias np="/mnt/d/NTSOA/INSTALLED/NODEJS/npm"

#this alias to call the windows nodeJS Program
alias node="node"

#this function for node alias
function node(){
  node.exe $@;
}

#this alias to run the windows mysql command
alias mysql="mysql"

#this function for mysql alias
function mysql(){
  mysql.exe $@;
}

kill-line() {
  if [[ $BUFFER == "" ]]; then
    zle backward-kill-line
  else
    zle kill-whole-line
  fi
}

zle -N kill-line
bindkey "²²" kill-line

# To customize prompt, run `p10k configure` or edit ~/.p10k.zsh.
[[ ! -f ~/.p10k.zsh ]] || source ~/.p10k.zsh

eval $(thefuck --alias)
